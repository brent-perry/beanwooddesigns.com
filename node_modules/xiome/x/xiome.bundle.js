(function () {
    'use strict';

    class RenrakuError extends Error {
        constructor() {
            super(...arguments);
            this.name = this.constructor.name;
        }
    }
    class ApiError extends RenrakuError {
        constructor(code, message) {
            super(message);
            this.code = code;
        }
    }
    class TimeoutError extends RenrakuError {
    }

    function objectMap$2(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    const is_service = Symbol("is_service");

    function isVoid$1(x) {
        return x === undefined || x === null;
    }

    /**
     * return a value within an object tree, found at the given path.
     */
    function obtain$1(object, path) {
        let current = object;
        for (const key of path) {
            current = current[key];
            if (isVoid$1(current))
                break;
        }
        return current;
    }

    function servelet(api) {
        return async function execute(request) {
            const servicePath = request.method.slice(1).split(".");
            const methodName = servicePath.pop();
            const service = obtain$1(api, servicePath);
            if (!service)
                throw new ApiError(400, `renraku service not found "${servicePath.join(".")}"`);
            const auth = await service.policy(request.meta, request.headers);
            const methods = service.expose(auth);
            const executor = methods[methodName];
            if (!executor)
                throw new ApiError(400, `renraku method "${methodName}" not found on service "${servicePath}"`);
            return executor(...request.params);
        };
    }

    const service = () => ({
        policy(p) {
            return {
                expose(e) {
                    return {
                        [is_service]: is_service,
                        expose: e,
                        policy: p,
                    };
                },
            };
        },
    });
    function api(api) {
        return api;
    }

    function remoteWithMetaMap(requester, map, options = {}) {
        function recurse(mapGroup, path = []) {
            return objectMap$2(mapGroup, (value, key) => {
                const newPath = [...path, key];
                if (typeof value === "function") {
                    const getMeta = value;
                    const overrides = {};
                    return new Proxy({}, {
                        set: (t, key, value) => {
                            overrides[key] = value;
                            return true;
                        },
                        get: (t, property) => {
                            var _a;
                            return ((_a = overrides[key]) !== null && _a !== void 0 ? _a : (async (...params) => {
                                const joinedPath = [...newPath, property].join(".");
                                const method = "." + joinedPath;
                                const meta = await getMeta();
                                return options.spike
                                    ? options.spike(joinedPath, async (...params2) => requester({
                                        meta, method, params: params2
                                    }), ...params)
                                    : requester({ meta, method, params });
                            }));
                        },
                    });
                }
                else {
                    return recurse(value, newPath);
                }
            });
        }
        return recurse(map);
    }

    function browserClient({ url, metaMap }) {
        let count = 0;
        async function requester({ meta, method, params }) {
            const response = await fetch(url, {
                method: "POST",
                mode: "cors",
                cache: "no-cache",
                credentials: "omit",
                redirect: "follow",
                referrerPolicy: "no-referrer",
                headers: {
                    // sent as plain text, to avoid cors "options" preflight requests,
                    // by qualifying as a cors "simple request"
                    "Content-Type": "text/plain; charset=utf-8",
                },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    method,
                    params,
                    id: count++,
                    meta,
                })
            }).then(r => r.json());
            const { error } = response;
            const { result } = response;
            if (error)
                throw new ApiError(error.code, `remote call error: ${error.code} ${error.message} (from "${url}")`);
            else
                return result;
        }
        return remoteWithMetaMap(requester, metaMap);
    }

    function isRequest(incoming) {
        return !!incoming.method;
    }

    function responseWaiter({ timeout }) {
        let requestCount = 0;
        const pendingResponses = new Map();
        return {
            startWaitingForResponse() {
                const id = requestCount++;
                return {
                    id,
                    response: new Promise((resolve, reject) => {
                        pendingResponses.set(id, {
                            resolve,
                            reject,
                            timeoutId: setTimeout(() => reject(new TimeoutError(`request (id ${id}) timed out`)), timeout),
                        });
                    }),
                };
            },
            resolvePendingResponse(id, result) {
                const waiter = pendingResponses.get(id);
                if (waiter) {
                    clearTimeout(waiter.timeoutId);
                    waiter.resolve(result);
                    pendingResponses.delete(id);
                }
            },
            rejectPendingResponse(id, reason) {
                const waiter = pendingResponses.get(id);
                if (waiter) {
                    clearTimeout(waiter.timeoutId);
                    waiter.reject(reason);
                    pendingResponses.delete(id);
                }
            },
        };
    }

    function stopwatch() {
        const start = Date.now();
        return () => Date.now() - start;
    }

    async function acceptIncomingRequest({ logger, exposeErrors, headers, request, servelet, respond, }) {
        var _a;
        const { id, meta, method, params } = request;
        try {
            const timer = stopwatch();
            const result = await servelet({
                meta,
                method,
                params,
                headers,
            });
            const duration = timer();
            respond({
                jsonrpc: "2.0",
                id,
                result,
            });
            logger.log(`🔻 ${method}() - ${duration}ms`);
        }
        catch (error) {
            if (!(error instanceof ApiError)) {
                error = new ApiError(500, exposeErrors
                    ? error.message
                    : "hidden error");
            }
            respond({
                jsonrpc: "2.0",
                id,
                error: {
                    code: error.code,
                    message: error.message,
                },
            });
            logger.error(`🚨 ${(_a = error.code) !== null && _a !== void 0 ? _a : 500}`, error.stack);
        }
    }

    async function acceptIncomingResponse({ logger, response, waiter }) {
        if (response.error) {
            const { id, error: { code, message } } = response;
            if (id === -1)
                logger.error(`🚨 ${code !== null && code !== void 0 ? code : 500} ${message}`);
            else
                waiter.rejectPendingResponse(id, new ApiError(code, message));
        }
        else {
            const { id, result } = response;
            waiter.resolvePendingResponse(id, result);
        }
    }

    function negotiator({ logger, timeout, exposeErrors }) {
        const waiter = responseWaiter({ timeout });
        return {
            startWaitingForResponse: waiter.startWaitingForResponse,
            async acceptIncoming({ servelet, headers, incoming, respond }) {
                if (isRequest(incoming))
                    acceptIncomingRequest({
                        logger,
                        headers,
                        exposeErrors,
                        request: incoming,
                        respond,
                        servelet,
                    });
                else
                    acceptIncomingResponse({
                        logger,
                        waiter,
                        response: incoming,
                    });
            },
        };
    }

    function noLogger() {
        return {
            log() { },
            warn() { },
            error() { },
        };
    }

    async function webSocketClient({ link, timeout, metaMap, clientApi, handleConnectionClosed, }) {
        const clientServelet = servelet(clientApi);
        const socket = await connectWebSocket(link);
        const { startWaitingForResponse, acceptIncoming } = negotiator({
            timeout,
            exposeErrors: true,
            logger: noLogger(),
        });
        const requester = async ({ meta, method, params }) => {
            const { id, response } = startWaitingForResponse();
            socket.send(JSON.stringify({
                jsonrpc: "2.0",
                id,
                meta,
                method,
                params,
            }));
            return response;
        };
        socket.onclose = () => handleConnectionClosed();
        socket.onerror = event => {
            console.error("socket error", event);
            socket.close();
            handleConnectionClosed();
        };
        socket.onmessage = async (event) => acceptIncoming({
            servelet: clientServelet,
            headers: undefined,
            incoming: JSON.parse(event.data.toString()),
            respond: response => socket.send(JSON.stringify(response)),
        });
        return {
            remote: remoteWithMetaMap(requester, metaMap),
            close: () => socket.close(),
        };
    }
    async function connectWebSocket(link) {
        return new Promise((resolve, reject) => {
            const socket = new WebSocket(link);
            socket.onopen = () => resolve(socket);
            socket.onerror = error => reject(error);
        });
    }

    /**
     * create a pub/sub context
     */
    function pubsub() {
        let listeners = [];
        return {
            publish: (async (...args) => {
                const operations = listeners.map(listener => listener(...args));
                await Promise.all(operations);
            }),
            subscribe(func) {
                listeners.push(func);
                return () => {
                    listeners = listeners.filter(listener => listener !== func);
                };
            },
            dispose: () => {
                listeners = [];
            },
        };
    }

    const browser = typeof atob === "function";
    function encode(text) {
        return browser
            ? btoa(text)
            : Buffer.from(text).toString("base64");
    }
    function decode(base64) {
        return browser
            ? atob(base64)
            : Buffer.from(base64, "base64").toString("binary");
    }
    const url$2 = Object.freeze({
        encode: (text) => {
            const base64 = encode(text);
            const base64url = addEqualsPadding(base64
                .replace(/=/g, "")
                .replace(/\+/g, "-")
                .replace(/\//g, "_"));
            return base64url;
        },
        decode: (base64url) => {
            const base64 = base64url
                .replace(/-/g, "+")
                .replace(/_/g, "/");
            return decode(base64);
        },
    });
    function addEqualsPadding(base64) {
        return base64 + Array((4 - base64.length % 4) % 4 + 1).join("=");
    }

    const tokenDecode = function decode(token) {
        const [headerPart, dataPart] = token.split(".");
        const header = decodePart(headerPart);
        const data = decodePart(dataPart);
        return { header, data };
    };
    function decodePart(part) {
        return JSON.parse(decodeURIComponent(url$2.decode(part)
            .split("")
            .map(c => "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2))
            .join("")));
    }

    const expiryRenewalCushion = 60 * 1000;
    function isTokenTimingExpired(exp) {
        const expiry = exp * 1000;
        return Date.now() > (expiry - expiryRenewalCushion);
    }

    function isTokenValid(token) {
        return !!token
            && !isTokenTimingExpired(tokenDecode(token).data.exp);
    }

    const decodeAccessToken = (accessToken) => {
        return tokenDecode(accessToken).data.payload;
    };

    function makeAuthMediator({ appId, storage, greenService, }) {
        const tokenChangeEvent = pubsub();
        const accessEvent = pubsub();
        const key = `auth-tokens-${appId}`;
        const emptyTokens = () => ({ accessToken: undefined, refreshToken: undefined });
        const getTokens = async () => { var _a; return (_a = await storage.read(key)) !== null && _a !== void 0 ? _a : emptyTokens(); };
        const setTokens = async (tokens) => storage.write(key, tokens);
        async function commitTokens(tokens) {
            const access = decodeAccessToken(tokens.accessToken);
            await setTokens(tokens);
            tokenChangeEvent.publish();
            await accessEvent.publish(access);
            return access;
        }
        async function authorize(refreshToken) {
            const accessToken = await greenService.authorize({
                appId,
                refreshToken,
                scope: { core: true },
            });
            const access = await commitTokens({ accessToken, refreshToken });
            return { access, accessToken };
        }
        const obtainAccessAndReauthorizeIfNecessary = (async () => {
            const { accessToken, refreshToken } = await getTokens();
            return isTokenValid(accessToken)
                ? { accessToken, access: decodeAccessToken(accessToken) }
                : isTokenValid(refreshToken)
                    ? authorize(refreshToken)
                    : authorize(undefined);
        });
        return {
            subscribeToAccessChange: accessEvent.subscribe,
            subscribeToTokenChange: tokenChangeEvent.subscribe,
            async initialize() {
                const { access } = await obtainAccessAndReauthorizeIfNecessary();
                await accessEvent.publish(access);
                return access;
            },
            async getValidAccess() {
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async getValidAccessToken() {
                return (await obtainAccessAndReauthorizeIfNecessary()).accessToken;
            },
            async login(tokens) {
                return commitTokens(tokens);
            },
            async logout() {
                await setTokens(emptyTokens());
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
            async reauthorize() {
                const tokens = await getTokens();
                await setTokens({ ...tokens, accessToken: undefined });
                return (await obtainAccessAndReauthorizeIfNecessary()).access;
            },
        };
    }

    function prepareApiShape({ appId, storage }) {
        let authMediator;
        async function getStandardMeta() {
            return {
                accessToken: await authMediator.getValidAccessToken(),
            };
        }
        const metaMap = {
            auth: {
                apps: {
                    appService: getStandardMeta,
                    appEditService: getStandardMeta,
                },
                permissions: {
                    permissionsService: getStandardMeta,
                },
                users: {
                    greenService: async () => undefined,
                    loginService: getStandardMeta,
                    personalService: getStandardMeta,
                    userService: getStandardMeta,
                },
            },
            example: {
                exampleService: getStandardMeta,
            },
            administrative: {
                roleAssignmentService: getStandardMeta,
            },
            questions: {
                questionsModerationService: getStandardMeta,
                questionsPostingService: getStandardMeta,
                questionsReadingService: getStandardMeta,
                questionsAnsweringService: getStandardMeta,
            },
            videos: {
                dacastService: getStandardMeta,
                contentService: getStandardMeta,
            },
            notes: {
                notesService: getStandardMeta,
            },
        };
        function installAuthMediator({ greenService }) {
            authMediator = makeAuthMediator({
                appId,
                storage,
                greenService,
            });
            return authMediator;
        }
        return {
            metaMap,
            installAuthMediator,
        };
    }

    function makeRemote({ appId, apiLink, storage, }) {
        const { metaMap, installAuthMediator } = prepareApiShape({
            appId,
            storage,
        });
        const remote = browserClient({
            metaMap,
            url: apiLink,
        });
        const authMediator = installAuthMediator({
            greenService: remote.auth.users.greenService,
        });
        return { remote, authMediator };
    }

    var PopupFlag;
    (function (PopupFlag) {
        // popup says "hey, i'm done loading"
        PopupFlag[PopupFlag["ReadyResponse"] = 0] = "ReadyResponse";
        // host page says "ok popup, now get to work"
        PopupFlag[PopupFlag["GoRequest"] = 1] = "GoRequest";
        // popup says "here's the result"
        PopupFlag[PopupFlag["PayloadResponse"] = 2] = "PayloadResponse";
        // popup says "this terrible error occurred"
        PopupFlag[PopupFlag["ErrorResponse"] = 3] = "ErrorResponse";
    })(PopupFlag || (PopupFlag = {}));

    function centeredPopupFeatures(width = 260, height = 260) {
        const { outerWidth, outerHeight, screenY, screenX } = window.top;
        const top = ((outerHeight / 2) + screenY - (height / 2)) / 2;
        const left = (outerWidth / 2) + screenX - (width / 2);
        return `
		width=${width},
		height=${height},
		top=${top},
		left=${left},
		toolbar=no,
		location=no,
		status=no,
		menubar=no,
		scrollbars=yes,
		resizable=yes
	`;
    }

    function validateResponse({ event, namespace, popupOrigin, }) {
        const relevant = !!event.data
            && event.data.namespace === namespace;
        const originsMatch = event.origin.toLowerCase() === popupOrigin.toLowerCase();
        if (relevant) {
            if (originsMatch)
                return true;
            else
                console.warn(`message denied from origin "${event.origin}"`, event);
        }
        return false;
    }

    function openPopup({ popupLink, namespace, parameters, }) {
        const popupOrigin = new URL(popupLink).origin;
        // scope these variables high up, so we can return closePopup
        let popup;
        let messageListener;
        function closePopup() {
            window.removeEventListener("message", messageListener);
            popup.close();
        }
        const promisedPayload = new Promise((resolve, reject) => {
            messageListener = (event) => {
                const message = event.data;
                if (validateResponse({ event, popupOrigin, namespace })) {
                    try {
                        if (message.flag === PopupFlag.ReadyResponse) {
                            popup.postMessage({
                                namespace,
                                parameters,
                                flag: PopupFlag.GoRequest,
                            }, popupOrigin);
                        }
                        else if (message.flag === PopupFlag.PayloadResponse) {
                            const { payload } = message;
                            closePopup();
                            resolve(payload);
                        }
                        else if (message.flag === PopupFlag.ErrorResponse) {
                            const { error } = message;
                            closePopup();
                            reject(error);
                        }
                        else {
                            closePopup();
                            throw new Error("unknown popup message flag");
                        }
                    }
                    catch (error) {
                        closePopup();
                        reject(error);
                    }
                }
            };
        });
        window.addEventListener("message", messageListener);
        popup = window.open(popupLink, namespace, centeredPopupFeatures());
        popup.focus();
        return { closePopup, promisedPayload };
    }

    const bankPopupNamespace = "xiome-bank-popup";

    function openBankPopup({ popupLink, stripeAccountId, stripeAccountSetupLink, }) {
        return openPopup({
            popupLink,
            namespace: bankPopupNamespace,
            parameters: { stripeAccountId, stripeAccountSetupLink },
        });
    }

    function systemPopups({ popupsBase }) {
        return {
            triggerStripeConnectPopup: (async ({ stripeAccountId, stripeAccountSetupLink }) => {
                const result = openBankPopup({
                    popupLink: `${popupsBase}/bank`,
                    stripeAccountId,
                    stripeAccountSetupLink,
                });
                return result.promisedPayload;
            }),
        };
    }

    (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    ////////
    ////////
    ////////
    var Operation;
    (function (Operation) {
        (function (Type) {
            Type[Type["Create"] = 0] = "Create";
            Type[Type["Update"] = 1] = "Update";
            Type[Type["Delete"] = 2] = "Delete";
        })(Operation.Type || (Operation.Type = {}));
    })(Operation || (Operation = {}));

    function jsonStorage(storage) {
        return {
            read(key) {
                let data = undefined;
                const raw = storage.getItem(key);
                if (raw) {
                    try {
                        data = JSON.parse(raw);
                    }
                    catch (error) {
                        storage.removeItem(key);
                    }
                }
                return data;
            },
            write(key, data) {
                const json = JSON.stringify(data);
                storage.setItem(key, json);
            },
            delete(key) {
                storage.removeItem(key);
            },
        };
    }

    function simpleFlexStorage(storage) {
        const json = jsonStorage(storage);
        return {
            async read(key) {
                return json.read(key);
            },
            async write(key, data) {
                return json.write(key, data);
            },
            async delete(key) {
                return json.delete(key);
            },
        };
    }

    var _a;
    (typeof process !== "undefined")
        && (((_a = process === null || process === void 0 ? void 0 : process.release) === null || _a === void 0 ? void 0 : _a.name) === "node");

    (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    function chatSocketClient(link) {
        return async function chatConnect({ clientsideApi, handleDisconnect }) {
            const { remote, close } = await webSocketClient({
                link,
                timeout: 60000,
                clientApi: clientsideApi,
                metaMap: { chatServer: async () => { } },
                handleConnectionClosed: handleDisconnect,
            });
            return {
                serverside: remote,
                disconnect: close,
            };
        };
    }

    (function(global) {
        var channels = [];

        function BroadcastChannel(channel) {
            var $this = this;
            channel = String(channel);

            var id = '$BroadcastChannel$' + channel + '$';

            channels[id] = channels[id] || [];
            channels[id].push(this);

            this._name = channel;
            this._id = id;
            this._closed = false;
            this._mc = new MessageChannel();
            this._mc.port1.start();
            this._mc.port2.start();

            global.addEventListener('storage', function(e) {
                if (e.storageArea !== global.localStorage) return;
                if (e.newValue == null || e.newValue === '') return;
                if (e.key.substring(0, id.length) !== id) return;
                var data = JSON.parse(e.newValue);
                $this._mc.port2.postMessage(data);
            });
        }

        BroadcastChannel.prototype = {
            // BroadcastChannel API
            get name() {
                return this._name;
            },
            postMessage: function(message) {
                var $this = this;
                if (this._closed) {
                    var e = new Error();
                    e.name = 'InvalidStateError';
                    throw e;
                }
                var value = JSON.stringify(message);

                // Broadcast to other contexts via storage events...
                var key = this._id + String(Date.now()) + '$' + String(Math.random());
                global.localStorage.setItem(key, value);
                setTimeout(function() {
                    global.localStorage.removeItem(key);
                }, 500);

                // Broadcast to current context via ports
                channels[this._id].forEach(function(bc) {
                    if (bc === $this) return;
                    bc._mc.port2.postMessage(JSON.parse(value));
                });
            },
            close: function() {
                if (this._closed) return;
                this._closed = true;
                this._mc.port1.close();
                this._mc.port2.close();

                var index = channels[this._id].indexOf(this);
                channels[this._id].splice(index, 1);
            },

            // EventTarget API
            get onmessage() {
                return this._mc.port1.onmessage;
            },
            set onmessage(value) {
                this._mc.port1.onmessage = value;
            },
            addEventListener: function(/*type, listener , useCapture*/) {
                return this._mc.port1.addEventListener.apply(this._mc.port1, arguments);
            },
            removeEventListener: function(/*type, listener , useCapture*/) {
                return this._mc.port1.removeEventListener.apply(this._mc.port1, arguments);
            },
            dispatchEvent: function(/*event*/) {
                return this._mc.port1.dispatchEvent.apply(this._mc.port1, arguments);
            },
        };

        global.BroadcastChannel = global.BroadcastChannel || BroadcastChannel;
    })(self);

    function wireMediatorBroadcastChannel({ appId, authMediator }) {
        const channel = new BroadcastChannel("tokenChangeEvent");
        authMediator.subscribeToTokenChange(() => channel.postMessage({ appId }));
        channel.onmessage = (event) => {
            if (event.data.appId === appId)
                authMediator.initialize();
        };
    }

    function url$1(platformOrigin) {
        return new URL(platformOrigin);
    }
    async function connect({ appId, platformOrigin = `https://xiome.io`, apiServer = `${url$1(platformOrigin).protocol}//api.${url$1(platformOrigin).host}/`, chatServer = `${url$1(platformOrigin).protocol === "https:" ?
    "wss:" :
    "ws:"}//chat.${url$1(platformOrigin).host}/`, }) {
        const storage = simpleFlexStorage(window.localStorage);
        const { remote, authMediator } = makeRemote({
            appId,
            storage,
            apiLink: apiServer,
        });
        wireMediatorBroadcastChannel({ appId, authMediator });
        const popups = systemPopups({ popupsBase: `${platformOrigin}/popups` });
        const chatConnect = chatSocketClient(chatServer);
        return { appId, remote, storage, authMediator, popups, chatConnect };
    }

    function pub() {
        const records = new Map();
        return {
            subscribe(...listeners) {
                if (listeners.length) {
                    const id = Symbol();
                    records.set(id, listeners);
                    return () => {
                        records.delete(id);
                    };
                }
            },
            async publish(...args) {
                await Promise.all(Array.from(records.values())
                    .flat()
                    .map(listener => listener(...args)));
            },
            clear() {
                records.clear();
            },
        };
    }

    function onesie(operation) {
        let activeOperation;
        return async function (...args) {
            if (activeOperation)
                return activeOperation;
            else {
                activeOperation = operation(...args);
                const result = await activeOperation;
                activeOperation = undefined;
                return result;
            }
        };
    }

    var Ops;
    (function (Ops) {
        (function (Mode) {
            Mode[Mode["None"] = 0] = "None";
            Mode[Mode["Loading"] = 1] = "Loading";
            Mode[Mode["Error"] = 2] = "Error";
            Mode[Mode["Ready"] = 3] = "Ready";
        })(Ops.Mode || (Ops.Mode = {}));
    })(Ops || (Ops = {}));
    const ops = {
        none: () => ({
            mode: Ops.Mode.None,
        }),
        loading: () => ({
            mode: Ops.Mode.Loading,
        }),
        error: (reason) => ({
            mode: Ops.Mode.Error,
            reason,
        }),
        ready: (value) => ({
            mode: Ops.Mode.Ready,
            value,
        }),
        replaceValue(op, value) {
            return op.mode === Ops.Mode.Ready
                ? { ...op, value }
                : op;
        },
        isNone: (op) => op.mode === Ops.Mode.Ready,
        isLoading: (op) => op.mode === Ops.Mode.Loading,
        isError: (op) => op.mode === Ops.Mode.Error,
        isReady: (op) => op.mode === Ops.Mode.Ready,
        value(op) {
            return op.mode === Ops.Mode.Ready
                ? op.value
                : undefined;
        },
        select(op, options) {
            switch (op.mode) {
                case Ops.Mode.None: return options.none();
                case Ops.Mode.Loading: return options.loading();
                case Ops.Mode.Error: return options.error(op.reason);
                case Ops.Mode.Ready: return options.ready(op.value);
            }
        },
        async operation({ promise, errorReason = "an error occurred", setOp, }) {
            setOp(ops.loading());
            try {
                const value = await promise;
                setOp(ops.ready(value));
                return value;
            }
            catch (error) {
                setOp(ops.error(errorReason));
                throw error;
            }
        },
        mode(op) {
            return ops.select(op, {
                none: () => "none",
                loading: () => "loading",
                error: () => "error",
                ready: () => "ready",
            });
        },
        combine(...ops) {
            const isAnyError = !!ops.find(op => op.mode === Ops.Mode.Error);
            const isAnyLoading = !!ops.find(op => op.mode === Ops.Mode.Loading);
            const isAnyNotReady = !!ops.find(op => op.mode !== Ops.Mode.Ready);
            return isAnyError
                ? { mode: Ops.Mode.Error, reason: "error" }
                : isAnyLoading
                    ? { mode: Ops.Mode.Loading }
                    : isAnyNotReady
                        ? { mode: Ops.Mode.None }
                        : { mode: Ops.Mode.Ready, value: undefined };
        },
        debug(op) {
            return ops.select(op, {
                none: () => [`<op {mode: None}>`],
                loading: () => [`<op {mode: Loading}>`],
                error: reason => [`<op {mode: Error, reason: "${reason}"}>`],
                ready: value => [`<op {mode: Ready, value: `, value, `}>`],
            });
        },
    };

    function isVoid(x) {
        return x === undefined || x === null;
    }

    function obtain(object, path) {
        let current = object;
        for (const key of path) {
            current = current[key];
            if (isVoid(current))
                break;
        }
        return current;
    }

    function objectMap$1(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    function isPlainObject(value) {
        if (typeof value !== "object" || value === null)
            return false;
        const prototype = Object.getPrototypeOf(value);
        return prototype === Object.prototype || prototype === null;
    }

    const symbolToAllowProxyIntoState = Symbol("symbolToAllowProxyIntoState");

    function unproxy(x, unlessSymbol = symbolToAllowProxyIntoState) {
        return (isPlainObject(x) && !x[unlessSymbol])
            ? objectMap$1(x, value => unproxy(value, unlessSymbol))
            : x;
    }

    function debounce(delay, action) {
        let latestArgs;
        let timeout;
        let waitingQueue = [];
        function reset() {
            latestArgs = undefined;
            if (timeout)
                clearTimeout(timeout);
            timeout = undefined;
            waitingQueue = [];
        }
        reset();
        return ((...args) => {
            latestArgs = args;
            if (timeout)
                clearTimeout(timeout);
            const promise = new Promise((resolve, reject) => {
                waitingQueue.push({ resolve, reject });
            });
            timeout = setTimeout(() => {
                Promise.resolve()
                    .then(() => action(...latestArgs))
                    .then(r => {
                    for (const { resolve } of waitingQueue)
                        resolve(r);
                    reset();
                })
                    .catch(err => {
                    for (const { reject } of waitingQueue)
                        reject(err);
                    reset();
                });
            }, delay);
            return promise;
        });
    }

    function attemptNestedProperty(object, path, value) {
        const pathToSubObject = [...path];
        const finalKey = pathToSubObject.pop();
        let currentSubObject = object;
        for (const key of pathToSubObject) {
            if (typeof currentSubObject[key] === "object") {
                currentSubObject = currentSubObject[key];
            }
            else {
                throw new Error("unable to write property to object tree containing undefined");
            }
        }
        currentSubObject[finalKey] = value;
    }

    class SnapstateError extends Error {
        constructor() {
            super(...arguments);
            this.name = this.constructor.name;
        }
    }
    class SnapstateReadonlyError extends SnapstateError {
    }
    class SnapstateCircularError extends SnapstateError {
    }

    function containsPath(paths, path) {
        for (const comparisonPath of paths) {
            let mismatch = false;
            if (path.length === comparisonPath.length) {
                for (let i = 0; i < path.length; i++) {
                    if (path[i] !== comparisonPath[i]) {
                        mismatch = true;
                        break;
                    }
                }
                if (!mismatch)
                    return true;
            }
        }
        return false;
    }
    function containsPathOrChildren(paths, path) {
        for (const comparisonPath of paths) {
            let mismatch = false;
            if (path.length <= comparisonPath.length) {
                for (let i = 0; i < path.length; i++) {
                    if (path[i] !== comparisonPath[i]) {
                        mismatch = true;
                        break;
                    }
                }
                if (!mismatch)
                    return true;
            }
        }
        return false;
    }
    function containsPathOrParents(paths, path) {
        for (const comparisonPath of paths) {
            let mismatch = false;
            if (path.length >= comparisonPath.length) {
                for (let i = 0; i < comparisonPath.length; i++) {
                    if (comparisonPath[i] !== path[i]) {
                        mismatch = true;
                        break;
                    }
                }
                if (!mismatch)
                    return true;
            }
        }
        return false;
    }

    function snapstate(tree) {
        const masterTree = unproxy(tree, symbolToAllowProxyIntoState);
        let activeUpdate = false;
        let activeTrackThatIsRecording;
        const trackingSessions = new Map();
        const subscriptions = new Set();
        function findTrackingSessions(path) {
            const sessions = [];
            for (const [, session] of trackingSessions) {
                if (session.flip) {
                    if (containsPathOrParents(session.paths, path))
                        sessions.push(session);
                }
                else {
                    if (containsPathOrChildren(session.paths, path))
                        sessions.push(session);
                }
            }
            return sessions;
        }
        const writable = recurse(masterTree, true, []);
        const readable = recurse(masterTree, false, []);
        let updateQueue = [];
        const update = debounce(1, () => {
            for (const path of updateQueue) {
                activeUpdate = true;
                try {
                    for (const subscription of subscriptions) {
                        subscription(readable);
                    }
                    for (const { observer, reaction } of findTrackingSessions(path)) {
                        if (reaction)
                            reaction(observer(readable));
                        else
                            observer(readable);
                    }
                }
                finally {
                    activeUpdate = false;
                }
            }
            updateQueue = [];
        });
        let waiter = Promise.resolve();
        function queueUpdate(path) {
            if (!containsPath(updateQueue, path))
                updateQueue.push(path);
            waiter = update();
        }
        function recurse(target, allowWrites, path) {
            return new Proxy(target, {
                get(t, property) {
                    var _a;
                    const currentPath = [...path, property];
                    if (activeTrackThatIsRecording) {
                        if (!containsPath(activeTrackThatIsRecording.paths, currentPath)) {
                            activeTrackThatIsRecording.paths.push(currentPath);
                        }
                    }
                    const value = (_a = obtain(masterTree, currentPath)) !== null && _a !== void 0 ? _a : obtain(t, [property]);
                    return isPlainObject(value)
                        ? recurse(value, allowWrites, currentPath)
                        : value;
                },
                set(t, property, value) {
                    const currentPath = [...path, property];
                    if (allowWrites) {
                        if (activeTrackThatIsRecording || activeUpdate)
                            throw new SnapstateCircularError("forbidden state circularity");
                        const existingValue = obtain(masterTree, currentPath);
                        const isChanged = value !== existingValue;
                        if (isChanged) {
                            attemptNestedProperty(masterTree, currentPath, unproxy(value, symbolToAllowProxyIntoState));
                            queueUpdate(currentPath);
                        }
                        return true;
                    }
                    else {
                        throw new SnapstateReadonlyError(`state is read-only here, cannot set ${currentPath.join(".")}`);
                    }
                }
            });
        }
        const untrackers = new Set();
        const unsubscribers = new Set();
        return {
            state: writable,
            writable,
            readable,
            readonly: readable,
            subscribe(subscription) {
                subscriptions.add(subscription);
                const unsubscribe = () => subscriptions.delete(subscription);
                unsubscribers.add(unsubscribe);
                return unsubscribe;
            },
            track(observer, reaction, { flip = false } = {}) {
                const identifier = Symbol();
                activeTrackThatIsRecording = { paths: [], flip, observer, reaction };
                trackingSessions.set(identifier, activeTrackThatIsRecording);
                observer(readable);
                activeTrackThatIsRecording = undefined;
                const untrack = () => trackingSessions.delete(identifier);
                untrackers.add(untrack);
                return untrack;
            },
            unsubscribeAll() {
                for (const unsubscribe of unsubscribers)
                    unsubscribe();
                unsubscribers.clear();
            },
            untrackAll() {
                for (const untrack of untrackers)
                    untrack();
                untrackers.clear();
            },
            async wait() {
                await waiter;
            },
        };
    }

    function makeChatState() {
        return snapstate({
            accessOp: ops.none(),
            connectionOp: ops.none(),
            cache: {
                mutedUserIds: [],
                roomStats: {},
                rooms: {},
            },
        });
    }

    const chatRegularPrivileges = {
        "view all chats": "985dc13378d1129e4dd6303fe9e52dff97d53568ce10814805f481159c788710",
        "participate in all chats": "bd0c8dfdf3eef893a5d9f8b5d0a6cad19ad80e949ebd70428f0d7525099cdd10",
    };
    const chatPowerPrivileges = {
        "moderate all chats": "693d969777a3998de6f9a4a5583917f4e672bb96ed08c571fc7486593ca98993",
    };
    const chatPrivileges = {
        ...chatRegularPrivileges,
        ...chatPowerPrivileges,
    };

    function asPermissions(permissions) {
        return permissions;
    }
    function has(privileges, hasPrivilege) {
        const hasPrivileges = {};
        for (const key of Object.keys(privileges))
            hasPrivileges[key] = hasPrivilege;
        return hasPrivileges;
    }
    function mutable(active, privileges) {
        return has(privileges, { active, immutable: false });
    }
    function immutable(active, privileges) {
        return has(privileges, { active, immutable: true });
    }

    const storePowerPrivileges = {
        "control stripe account": "f236bd2175fbecf7925483884b8c2a2ffe0dd2f0a864cbd638046f6fc58944b5",
        "manage store": "bea0ef0db58a0d8c9ab96bb9b14f889a19893064361b0877626b510b798c6fb8",
        "give away freebies": "c2712efd490c67b44946bc6e1bbe82aee5b8ede384cff614ba7435d429993ec6",
    };

    const videoPowerPrivileges = {
        "view all videos": "22f380eb0c5c7463b8a16fcdfc2f5e58257d38f94972924e70d27a08fabb5506",
        "moderate videos": "1b19013344a59cb49bfd9bddc8dd817a9e4cfa29003437021df24bdc832ec246",
    };
    const videoPrivileges = { ...videoPowerPrivileges };

    const universalPrivilege = "c1cb5ac1000af6081ff47e80804de7542b57a1425c3faac8153e708aaf79271a";
    const commonPrivileges = {
        "read questions": "5b19b929648cbbe26c052a5016892b370f048eead1e6a303a50b7f5234ec5161",
        "post questions": "aeaae6139d05f77193ca7c272a65977c70cb188f3070359866237a5ade84ba15",
        "like questions": "5490898c541d733956b28664e7536673842e73b289fc45ab9caf143138c14a3e",
        "report questions": "f2f89d433f398b267e320e0e3b9929eb3934af5c02f7e3fb2e032fd19399ad21",
        ...chatRegularPrivileges,
    };
    const commonPowerPrivileges = {
        "edit any profile": "4240ca0331e8679a444c6c4c6a803d8a12893f1554460af426064b980164c8ee",
        "customize permissions": "f380d9b4d1001da8dc86a6e0b6a0721b92ed8060c52cd4ba433e76cbd9efe6b5",
        "answer questions": "afaa00f7bc9ab09d3bbc61a26f6d9bc666cd9bb7ac270ebbdeba3cf4dd3ab9a9",
        "moderate questions": "f6a3152a13f313a60f84d82ba8f7765afb19f70c04ef14688d802237a5d2ab5e",
        "view stats": "092866ae6378833e43ec7001188aa1829d4cf2858e42da0ad3f44a2fedbcb07b",
        "administrate user roles": "a072e9dd003a762e7d693658d8ac724be352b18da240843f691595c89020e350",
        ...videoPowerPrivileges,
        ...storePowerPrivileges,
        ...chatPowerPrivileges,
    };
    const platformPowerPrivileges = {
        "edit any app": "e5fadb4b03badd6699b355ec43e1d150d6f4df81ecc291b5b742f06ebe62a0f8",
        "view platform stats": "eec7d2ddc20df6080c4166a3dea0b2643b483ce61326cbefad95e45824810692",
    };
    const appPowerPrivileges = {};
    const active = true;
    const INACTIVE = false;
    const universalPermissions = asPermissions({
        privileges: {
            ...commonPrivileges,
            ...commonPowerPrivileges,
            "universal": universalPrivilege,
            "banned": "ffff9ebcbe8f69f3520ec574f5a1489a70bf04521d7a85fcbd25c54cc22802f1",
        },
        roles: {
            "everybody": {
                roleId: "aaaa777dc7d7e9b5e9e0386abf0cf2f059cda4f71779cc910b85e8f504452b23",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: true, immutable: true },
                    "banned": { active: false, immutable: true },
                    "read questions": { active: true, immutable: false },
                    "view all chats": { active: true, immutable: false },
                },
            },
            "authenticated": {
                roleId: "bbbb642d549d06113953a01fb52a8e010150edc502b929395bfb32d250d44b1c",
                public: false,
                assignable: false,
                hasPrivileges: {
                    ...mutable(active, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
            "banned": {
                roleId: "dead633608412f8eefbb40f4678ef2bafaeb7883d09a6094dafe5f69dd6a8684",
                public: true,
                assignable: true,
                hasPrivileges: {
                    ...immutable(INACTIVE, commonPrivileges),
                    ...immutable(INACTIVE, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: true, immutable: true },
                },
            },
            "technician": {
                roleId: "9999d97119a83ea3853273a93e24ae0a1f2a994eccb21dacacab6ff860d8d869",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
        },
    });
    asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...platformPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "everybody": {
                ...universalPermissions.roles.everybody,
                hasPrivileges: {
                    ...universalPermissions.roles.everybody.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, platformPowerPrivileges),
                }
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, platformPowerPrivileges),
                },
            },
        },
    });
    const appPermissions = asPermissions({
        privileges: {
            ...universalPermissions.privileges,
            ...appPowerPrivileges,
        },
        roles: {
            ...universalPermissions.roles,
            "everybody": {
                ...universalPermissions.roles.everybody,
                hasPrivileges: {
                    ...universalPermissions.roles.everybody.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "authenticated": {
                ...universalPermissions.roles.authenticated,
                hasPrivileges: {
                    ...universalPermissions.roles.authenticated.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "banned": {
                ...universalPermissions.roles.banned,
                hasPrivileges: {
                    ...universalPermissions.roles.banned.hasPrivileges,
                    ...immutable(INACTIVE, appPowerPrivileges),
                }
            },
            "admin": {
                roleId: "d21e66058b95b3b2e80c1a00c82abd56b8ec7a4b20f0424c2a00cc6ba352efeb",
                public: true,
                assignable: false,
                hasPrivileges: {
                    ...immutable(active, appPowerPrivileges),
                    ...immutable(active, commonPrivileges),
                    ...immutable(active, commonPowerPrivileges),
                    "universal": { active: false, immutable: true },
                    "banned": { active: false, immutable: true },
                },
            },
            "technician": {
                ...universalPermissions.roles.technician,
                hasPrivileges: {
                    ...universalPermissions.roles.technician.hasPrivileges,
                    ...immutable(active, appPowerPrivileges),
                },
            },
        },
    });

    function chatAllowance(privileges) {
        return {
            moderateAllChats: privileges.includes(chatPrivileges["moderate all chats"]),
            participateInAllChats: privileges.includes(chatPrivileges["moderate all chats"]) ||
                privileges.includes(chatPrivileges["participate in all chats"]),
            viewAllChats: privileges.includes(chatPrivileges["moderate all chats"]) ||
                privileges.includes(chatPrivileges["participate in all chats"]) ||
                privileges.includes(chatPrivileges["view all chats"]),
            banned: privileges.includes(appPermissions.privileges["banned"]),
        };
    }

    var ChatStatus;
    (function (ChatStatus) {
        ChatStatus[ChatStatus["Offline"] = 0] = "Offline";
        ChatStatus[ChatStatus["Online"] = 1] = "Online";
    })(ChatStatus || (ChatStatus = {}));

    function makeChatRoom({ label, serverside, state }) {
        const getRoomCache = () => state.readable.cache.rooms[label];
        const getAccess = () => ops.value(state.readable.accessOp);
        return {
            get posts() {
                var _a, _b;
                return (_b = (_a = getRoomCache()) === null || _a === void 0 ? void 0 : _a.posts) !== null && _b !== void 0 ? _b : [];
            },
            get status() {
                var _a, _b;
                return (_b = (_a = getRoomCache()) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : ChatStatus.Offline;
            },
            get muted() {
                return state.readable.cache.mutedUserIds;
            },
            get weAreMuted() {
                const { user: { userId } } = getAccess();
                return state.readable.cache.mutedUserIds.includes(userId);
            },
            get weAreBanned() {
                const { permit: { privileges } } = getAccess();
                return privileges.includes(appPermissions.privileges["banned"]);
            },
            setRoomStatus(status) {
                serverside.chatServer.setRoomStatus(label, status);
            },
            post(draft) {
                serverside.chatServer.post(label, draft);
            },
            remove(postIds) {
                serverside.chatServer.remove(label, postIds);
            },
            clear() {
                serverside.chatServer.clear(label);
            },
            mute(userId) {
                serverside.chatServer.mute([userId]);
            },
            unmute(userId) {
                serverside.chatServer.unmute([userId]);
            },
            unmuteAll() {
                serverside.chatServer.unmuteAll();
            },
        };
    }

    function setupRoomManagement({ state, reconnect, disconnect }) {
        async function assertConnection() {
            return ops.isReady(state.readable.connectionOp)
                ? ops.value(state.readable.connectionOp)
                : reconnect();
        }
        const followers = new Map();
        const rooms = new Map();
        function assertFollowing(label) {
            let following = followers.get(label);
            if (!following) {
                following = new Set();
                followers.set(label, following);
            }
            return following;
        }
        function assertRoom(label) {
            let room = rooms.get(label);
            if (!room) {
                room = assertConnection()
                    .then(connection => connection.serverside.chatServer.roomSubscribe(label)
                    .then(() => connection))
                    .then(connection => makeChatRoom({
                    label,
                    state,
                    serverside: connection.serverside,
                }));
                rooms.set(label, room);
            }
            return room;
        }
        function removeRoom(label) {
            const room = rooms.get(label);
            assertConnection()
                .then(connection => room.then(r => {
                connection.serverside.chatServer.roomUnsubscribe(label);
            }))
                .then(() => {
                rooms.delete(label);
                if (rooms.size === 0) {
                    return disconnect();
                }
            });
        }
        async function getRoomSession(label) {
            const following = assertFollowing(label);
            const follower = Symbol();
            following.add(follower);
            function dispose() {
                following.delete(follower);
                if (following.size === 0)
                    removeRoom(label);
            }
            return {
                dispose,
                room: await assertRoom(label),
            };
        }
        async function updateAuthSituation(auth) {
            if (auth) {
                if (rooms.size > 0)
                    await assertConnection();
            }
            else if (rooms.size === 0)
                await disconnect();
        }
        return { getRoomSession, updateAuthSituation };
    }

    function makeStatsFetcher({ state, intervalDuration }) {
        let intervalId = undefined;
        function clearStatsInterval() {
            clearInterval(intervalId);
            intervalId = undefined;
        }
        return {
            startInterval(connection) {
                clearStatsInterval();
                intervalId = setInterval(async () => {
                    const stats = await connection.serverside.chatServer.getStats();
                    state.writable.cache.roomStats = stats;
                }, intervalDuration);
            },
            stopInterval: clearStatsInterval,
        };
    }

    const chatPostMaxLength = 280;
    const chatPostCoolOff = 3000;
    const maximumNumberOfPostsShownAtOnce = 50;

    const makeChatClientside = ({ state, onChange }) => api({
        chatClient: service()
            .policy(async () => { })
            .expose(() => {
            async function triggerChange() {
                await state.wait();
                onChange();
            }
            return {
                async roomStatusChanged(room, status) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                status,
                            },
                        },
                    };
                    await triggerChange();
                },
                async postsAdded(room, posts) {
                    var _a, _b;
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: [
                                    ...(_b = (_a = state.writable.cache.rooms[room]) === null || _a === void 0 ? void 0 : _a.posts) !== null && _b !== void 0 ? _b : [],
                                    ...posts,
                                ].slice(0, maximumNumberOfPostsShownAtOnce)
                            },
                        },
                    };
                    await triggerChange();
                },
                async postsRemoved(room, postIds) {
                    var _a, _b;
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: ((_b = (_a = state.writable.cache.rooms[room]) === null || _a === void 0 ? void 0 : _a.posts) !== null && _b !== void 0 ? _b : [])
                                    .filter(post => !postIds.includes(post.postId))
                            },
                        },
                    };
                    await triggerChange();
                },
                async roomCleared(room) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        rooms: {
                            ...state.writable.cache.rooms,
                            [room]: {
                                ...state.writable.cache.rooms[room],
                                posts: [],
                            },
                        },
                    };
                    await triggerChange();
                },
                async usersMuted(userIds) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: [
                            ...state.writable.cache.mutedUserIds,
                            ...userIds,
                        ],
                    };
                    await triggerChange();
                },
                async usersUnmuted(userIds) {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: state.writable.cache.mutedUserIds
                            .filter(userId => !userIds.includes(userId)),
                    };
                    await triggerChange();
                },
                async unmuteAll() {
                    state.writable.cache = {
                        ...state.writable.cache,
                        mutedUserIds: [],
                    };
                    await triggerChange();
                },
            };
        })
    });

    function makeChatModel({ chatConnect, getChatMeta }) {
        const changeEvent = pub();
        const state = makeChatState();
        const clientsideApi = makeChatClientside({
            state,
            onChange: changeEvent.publish,
        });
        const statsFetcher = makeStatsFetcher({ state, intervalDuration: 2000 });
        const reconnect = onesie(async function () {
            var _a;
            const connection = (_a = ops.value(state.readable.connectionOp)) !== null && _a !== void 0 ? _a : await ops.operation({
                setOp: op => state.writable.connectionOp = op,
                promise: chatConnect({
                    clientsideApi,
                    handleDisconnect: () => state.writable.connectionOp = ops.none(),
                }),
            });
            const meta = await getChatMeta();
            await connection.serverside.chatServer.updateUserMeta(meta);
            statsFetcher.startInterval(connection);
            return connection;
        });
        async function disconnect() {
            statsFetcher.stopInterval();
            const connection = ops.value(state.readable.connectionOp);
            if (connection) {
                connection.disconnect();
                state.writable.connectionOp = ops.none();
            }
        }
        const roomManagement = setupRoomManagement({
            state,
            reconnect,
            disconnect,
        });
        return {
            state: state.readable,
            subscribe: state.subscribe,
            subscribeToChange: changeEvent.subscribe,
            get allowance() {
                var _a;
                const access = ops.value(state.readable.accessOp);
                const privileges = (_a = access === null || access === void 0 ? void 0 : access.permit.privileges) !== null && _a !== void 0 ? _a : [];
                return chatAllowance(privileges);
            },
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                const access = ops.value(op);
                await roomManagement.updateAuthSituation(!!access);
                const connection = ops.value(state.readable.connectionOp);
                if (connection) {
                    const meta = await getChatMeta();
                    await connection.serverside.chatServer.updateUserMeta(meta);
                }
            },
            session: roomManagement.getRoomSession,
            disconnect,
            reconnect,
        };
    }

    function subbies() {
        const memory = new Map();
        return {
            subscribe(listener) {
                const symbol = Symbol();
                memory.set(symbol, listener);
                return () => {
                    memory.delete(symbol);
                };
            },
            publish: (context => {
                for (const [, listener] of memory)
                    listener(context);
            }),
            clear() {
                memory.clear();
            },
        };
    }

    function prepareNotesCacheCreator({ propagateChangeToOtherTabs, notesService, getStats, loadStats, getIsLoggedIn, }) {
        async function loadNewNotes(pagination) {
            return notesService.getNewNotes(pagination);
        }
        async function loadOldNotes(pagination) {
            return notesService.getOldNotes(pagination);
        }
        async function markNotesNewOrOld(old, noteIds) {
            await notesService.markNotesNewOrOld({ old, noteIds });
            await loadStats();
            propagateChangeToOtherTabs.publish(undefined);
        }
        return function createNotesCache() {
            const cacheState = snapstate({
                old: false,
                pageNumber: 1,
                pageSize: 10,
                notesOp: ops.none(),
            });
            function resetPagination() {
                cacheState.writable.pageNumber = 1;
                cacheState.writable.pageSize = 10;
            }
            async function fetchAppropriateNotes() {
                if (!getIsLoggedIn()) {
                    cacheState.writable.notesOp = ops.ready([]);
                    return [];
                }
                const { old, pageNumber, pageSize } = cacheState.readable;
                const pagination = {
                    offset: ((pageNumber - 1) * pageSize),
                    limit: pageSize,
                };
                await ops.operation({
                    setOp: op => cacheState.writable.notesOp = op,
                    promise: old
                        ? loadOldNotes(pagination)
                        : loadNewNotes(pagination),
                });
            }
            function totalNumberOfPages() {
                const { old, pageSize } = cacheState.readable;
                const { oldCount, newCount } = getStats();
                const count = old
                    ? oldCount
                    : newCount;
                return Math.ceil(count / pageSize);
            }
            const isPageAvailable = {
                next: () => cacheState.writable.pageNumber < totalNumberOfPages(),
                previous: () => cacheState.writable.pageNumber > 1,
            };
            return {
                subscribe: cacheState.subscribe,
                cacheState: cacheState.readable,
                async loginStatusChanged() {
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                get notes() {
                    return ops.value(cacheState.readable.notesOp);
                },
                fetchAppropriateNotes,
                async switchTabNew() {
                    cacheState.writable.old = false;
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                async switchTabOld() {
                    cacheState.writable.old = true;
                    resetPagination();
                    await fetchAppropriateNotes();
                },
                get isNextPageAvailable() {
                    return isPageAvailable.next();
                },
                get isPreviousPageAvailable() {
                    return isPageAvailable.previous();
                },
                async nextPage() {
                    if (isPageAvailable.next()) {
                        cacheState.writable.pageNumber += 1;
                        await fetchAppropriateNotes();
                    }
                    else
                        throw new Error("no next page");
                },
                async previousPage() {
                    if (isPageAvailable.previous()) {
                        cacheState.writable.pageNumber -= 1;
                        await fetchAppropriateNotes();
                    }
                    else
                        throw new Error("no previous page");
                },
                async markAllNotesOld() {
                    await notesService.markAllNotesOld();
                    await loadStats();
                    propagateChangeToOtherTabs.publish(undefined);
                    await fetchAppropriateNotes();
                },
                async markSpecificNoteOld(noteId) {
                    await markNotesNewOrOld(true, [noteId]);
                    cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                        ? cacheState.writable.pageNumber -= 1
                        : null;
                    await fetchAppropriateNotes();
                },
                async markSpecificNoteNew(noteId) {
                    await markNotesNewOrOld(false, [noteId]);
                    cacheState.readable.pageNumber > totalNumberOfPages() && cacheState.readable.pageNumber > 1
                        ? cacheState.writable.pageNumber -= 1
                        : null;
                    await fetchAppropriateNotes();
                },
                get totalPages() {
                    return totalNumberOfPages();
                },
            };
        };
    }

    function makeNotesModel({ notesService }) {
        const state = snapstate({
            accessOp: ops.none(),
            statsOp: ops.none(),
        });
        const accessUpdate = subbies();
        const propagateChangeToOtherTabs = subbies();
        function getIsLoggedIn() {
            var _a;
            return !!((_a = ops.value(state.readable.accessOp)) === null || _a === void 0 ? void 0 : _a.user);
        }
        function getStats() {
            var _a;
            return (_a = ops.value(state.readable.statsOp)) !== null && _a !== void 0 ? _a : {
                newCount: 0,
                oldCount: 0,
            };
        }
        const loadStats = onesie(async function loadStats() {
            return ops.operation({
                promise: notesService.getNotesStats(),
                setOp: op => state.writable.statsOp = op,
            });
        });
        let initialized = false;
        async function initialize() {
            if (!initialized) {
                initialized = true;
                if (getIsLoggedIn()) {
                    return loadStats();
                }
            }
        }
        async function loadIfInitialized() {
            if (initialized)
                return loadStats();
        }
        return {
            initialize,
            state: state.readable,
            stateSubscribe: state.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                if (getIsLoggedIn())
                    await loadIfInitialized();
                accessUpdate.publish(ops.value(op));
            },
            get isLoggedIn() {
                return getIsLoggedIn();
            },
            get stats() {
                return getStats();
            },
            propagateChangeToOtherTabs,
            loadStats,
            overwriteStatsOp(op) {
                state.writable.statsOp = op;
            },
            createNotesCacheDetails: (() => {
                const create = prepareNotesCacheCreator({
                    notesService,
                    propagateChangeToOtherTabs,
                    getStats,
                    loadStats,
                    getIsLoggedIn,
                });
                return () => {
                    const cache = create();
                    return {
                        cache,
                        setup: () => accessUpdate.subscribe(() => cache.loginStatusChanged()),
                    };
                };
            })(),
        };
    }

    function makeDacastModel({ dacastService }) {
        const linkChange = subbies();
        const state = snapstate({
            accessOp: ops.none(),
            linkedAccountOp: ops.none(),
        });
        let alreadyInitialized = false;
        const isModerator = () => {
            const access = ops.value(state.readable.accessOp);
            return access && access.permit.privileges.includes(videoPrivileges["moderate videos"]);
        };
        async function loadLinkedAccount() {
            return ops.operation({
                promise: dacastService.getLink(),
                setOp: op => state.writable.linkedAccountOp = op,
            });
        }
        async function refresh() {
            if (alreadyInitialized && isModerator()) {
                await loadLinkedAccount();
            }
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            onLinkChange: linkChange.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                state.writable.linkedAccountOp = ops.none();
                await refresh();
            },
            async initialize() {
                if (!alreadyInitialized) {
                    alreadyInitialized = true;
                    await refresh();
                }
            },
            get linkedAccount() {
                return ops.value(state.readable.linkedAccountOp);
            },
            async linkAccount({ apiKey }) {
                return ops.operation({
                    setOp: op => state.writable.linkedAccountOp = op,
                    promise: dacastService.setLink({ apiKey })
                        .then(link => {
                        linkChange.publish(link);
                        return link;
                    }),
                });
            },
            async unlinkAccount() {
                return ops.operation({
                    setOp: op => state.writable.linkedAccountOp = op,
                    promise: dacastService.clearLink()
                        .then(() => linkChange.publish(undefined)),
                });
            },
        };
    }

    function makeContentModel({ contentService, }) {
        const state = snapstate({
            accessOp: ops.none(),
            catalogOp: ops.none(),
            viewsOp: ops.none(),
            privilegesOp: ops.none(),
            showsOp: ops.none(),
        });
        const activeShowLabels = new Set();
        const currentlyLoadingShows = new Set();
        function getAccess() {
            return ops.value(state.readable.accessOp);
        }
        let initialized = false;
        async function loadModerationData() {
            initialized = true;
            const access = getAccess();
            const isModerator = access && access.permit
                .privileges.includes(videoPrivileges["moderate videos"]);
            if (isModerator) {
                await ops.operation({
                    promise: contentService.fetchModerationData(),
                    setOp: op => {
                        var _a, _b, _c;
                        const data = ops.value(op);
                        state.writable.catalogOp = ops.replaceValue(op, (_a = data === null || data === void 0 ? void 0 : data.catalog) !== null && _a !== void 0 ? _a : []);
                        state.writable.viewsOp = ops.replaceValue(op, (_b = data === null || data === void 0 ? void 0 : data.views) !== null && _b !== void 0 ? _b : []);
                        state.writable.privilegesOp = ops.replaceValue(op, (_c = data === null || data === void 0 ? void 0 : data.privileges) !== null && _c !== void 0 ? _c : []);
                    },
                });
            }
        }
        async function loadShow(label) {
            var _a;
            initialized = true;
            activeShowLabels.add(label);
            if (!getAccess() || currentlyLoadingShows.has(label))
                return undefined;
            currentlyLoadingShows.add(label);
            const oldShows = (_a = ops.value(state.readable.showsOp)) !== null && _a !== void 0 ? _a : [];
            let updatedShow;
            await ops.operation({
                setOp: op => state.writable.showsOp = op,
                promise: contentService.getShows({ labels: [label] })
                    .then(shows => shows[0])
                    .then(show => updatedShow = show)
                    .then(show => [
                    ...oldShows.filter(s => s.label !== label),
                    ...(show ? [show] : [{ label, details: undefined }]),
                ]),
            });
            currentlyLoadingShows.delete(label);
            return updatedShow;
        }
        async function refreshShows() {
            initialized = true;
            if (!getAccess())
                return undefined;
            const labels = Array.from(activeShowLabels)
                .filter(label => !currentlyLoadingShows.has(label));
            if (labels.length) {
                for (const label of labels)
                    currentlyLoadingShows.add(label);
                await ops.operation({
                    setOp: op => state.writable.showsOp = op,
                    promise: contentService.getShows({ labels })
                        .then(shows => shows.filter(s => !!s))
                });
                for (const label of labels)
                    currentlyLoadingShows.delete(label);
            }
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                state.writable.catalogOp = ops.none();
                state.writable.viewsOp = ops.none();
                if (initialized) {
                    await loadModerationData();
                    await refreshShows();
                }
            },
            async onVideoHostingUpdate() {
                if (initialized) {
                    await loadModerationData();
                    await refreshShows();
                }
            },
            async initializeForModerationData() {
                if (!initialized) {
                    await loadModerationData();
                }
            },
            async initializeForVideo(label) {
                if (!initialized)
                    await loadModerationData();
                await loadShow(label);
            },
            get allowance() {
                const access = ops.value(state.readable.accessOp);
                const can = (p) => access
                    ? access.permit.privileges.includes(videoPrivileges[p])
                    : false;
                return {
                    canModerateVideos: can("moderate videos"),
                    canViewAllVideos: can("moderate videos") || can("view all videos"),
                };
            },
            get catalog() {
                var _a;
                return (_a = ops.value(state.readable.catalogOp)) !== null && _a !== void 0 ? _a : [];
            },
            get views() {
                var _a;
                return (_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [];
            },
            get privileges() {
                var _a;
                return (_a = ops.value(state.readable.privilegesOp)) !== null && _a !== void 0 ? _a : [];
            },
            get shows() {
                var _a;
                return (_a = ops.value(state.readable.showsOp)) !== null && _a !== void 0 ? _a : [];
            },
            getView(label) {
                var _a;
                return ((_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [])
                    .find(view => view.label === label);
            },
            getPrivilege(id) {
                var _a;
                return ((_a = ops.value(state.readable.privilegesOp)) !== null && _a !== void 0 ? _a : [])
                    .find(p => p.privilegeId === id);
            },
            getShow(label) {
                var _a;
                return ((_a = ops.value(state.readable.showsOp)) !== null && _a !== void 0 ? _a : [])
                    .find(show => show.label === label);
            },
            async setView(options) {
                var _a;
                const oldViews = (_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [];
                await ops.operation({
                    setOp: op => state.writable.viewsOp = op,
                    promise: contentService.writeView(options).then(() => [
                        ...oldViews.filter(v => v.label !== options.label),
                        {
                            ...options.reference,
                            label: options.label,
                            privileges: options.privileges,
                        },
                    ]),
                });
                await loadShow(options.label);
            },
            async deleteView(label) {
                var _a, _b;
                const oldViews = (_a = ops.value(state.readable.viewsOp)) !== null && _a !== void 0 ? _a : [];
                await ops.operation({
                    setOp: op => state.writable.viewsOp = op,
                    promise: contentService.deleteView({ label })
                        .then(() => oldViews.filter(v => v.label !== label)),
                });
                const oldShows = (_b = ops.value(state.readable.showsOp)) !== null && _b !== void 0 ? _b : [];
                state.writable.showsOp = ops.replaceValue(state.readable.showsOp, oldShows.filter(s => s.label !== label));
            },
        };
    }

    function makeVideoModels(options) {
        const dacastModel = makeDacastModel(options);
        const contentModel = makeContentModel(options);
        dacastModel.onLinkChange(contentModel.onVideoHostingUpdate);
        return {
            dacastModel,
            contentModel,
            updateAccessOp(accessOp) {
                dacastModel.updateAccessOp(accessOp);
                contentModel.updateAccessOp(accessOp);
            },
        };
    }

    function makeExampleModel({ getAccessOp }) {
        const state = snapstate({
            accessOp: getAccessOp(),
        });
        return {
            state: state.readable,
            subscribe: state.subscribe,
            updateAccessOp: (op) => {
                state.writable.accessOp = op;
            },
        };
    }

    function makeAppsModel({ appService, appEditService, getValidAccess, }) {
        const { readable, writable, subscribe } = snapstate({
            active: false,
            appRecords: ops.none(),
            addingNewApp: ops.none(),
        });
        const actions = {
            setAppRecords(op) {
                var _a;
                const appList = (_a = ops.value(op)) !== null && _a !== void 0 ? _a : [];
                let records = {};
                for (const app of appList)
                    records[app.appId] = ops.ready(app);
                writable.appRecords = ops.replaceValue(op, records);
            },
            setIndividualAppRecord(appId, op) {
                var _a;
                if (ops.isLoading(writable.appRecords))
                    throw new Error("cannot set individual app while apps are loading");
                const apps = (_a = ops.value(writable.appRecords)) !== null && _a !== void 0 ? _a : {};
                writable.appRecords = ops.ready({ ...apps, [appId]: op });
            },
            deleteIndividualAppRecord(appId) {
                if (ops.isReady(writable.appRecords)) {
                    const existingRecords = ops.value(writable.appRecords);
                    const records = {};
                    for (const [key, value] of Object.entries(existingRecords)) {
                        if (key !== appId)
                            records[key] = value;
                    }
                    writable.appRecords = ops.ready(records);
                }
                else
                    throw new Error("cannot delete individual app while apps are loading");
            },
        };
        async function getUserId() {
            var _a;
            const access = await getValidAccess();
            return (_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId;
        }
        async function loadApps() {
            writable.active = true;
            const appsPromise = ops.operation({
                promise: (async () => {
                    const userId = await getUserId();
                    return userId
                        ? appService.listApps({ ownerUserId: userId })
                        : [];
                })(),
                setOp: op => actions.setAppRecords(op),
            });
            // actions.setLoadingPromise(appsPromise.then(() => undefined))
            return appsPromise;
        }
        async function registerApp(appDraft) {
            const userId = await getUserId();
            const result = await ops.operation({
                errorReason: "failed to register app",
                promise: (async () => {
                    const result = await appService.registerApp({
                        appDraft,
                        ownerUserId: userId,
                    });
                    await appEditService.assignPlatformUserAsAdmin({
                        appId: result.appId,
                        platformUserId: userId,
                    });
                    return result;
                })(),
                setOp: op => {
                    writable.addingNewApp = ops.replaceValue(op, null);
                    if (ops.isReady(op)) {
                        const newApp = { ...ops.value(op), ...appDraft };
                        actions.setIndividualAppRecord(newApp.appId, ops.ready(newApp));
                    }
                },
            });
            return result;
        }
        async function updateApp(appId, appDraft) {
            const records = ops.value(writable.appRecords);
            if (!records)
                throw new Error("cannot update app while loading records");
            const existingApp = ops.value(records[appId]);
            if (!existingApp)
                throw new Error("cannot update app not present in records");
            return ops.operation({
                promise: appEditService.updateApp({ appId, appDraft }),
                setOp: op => actions.setIndividualAppRecord(appId, ops.replaceValue(op, { ...existingApp, ...appDraft })),
            });
        }
        function getApp(appId) {
            const records = ops.value(writable.appRecords);
            return records
                ? ops.value(records[appId])
                : undefined;
        }
        async function deleteApp(appId) {
            await ops.operation({
                promise: appEditService.deleteApp({ appId }),
                setOp: op => {
                    actions.setIndividualAppRecord(appId, ops.replaceValue(op, getApp(appId)));
                },
            });
            actions.deleteIndividualAppRecord(appId);
        }
        return {
            state: readable,
            subscribe,
            appEditService,
            getApp,
            loadApps,
            deleteApp,
            updateApp,
            registerApp,
            async updateAccessOp(op) {
                if (readable.active)
                    await loadApps();
            },
        };
    }

    function merge(newItems, oldItems, compare) {
        const result = [...newItems];
        for (const oldItem of oldItems) {
            const included = !!result.find(newItem => compare(newItem, oldItem));
            if (!included)
                result.push(oldItem);
        }
        return result;
    }

    function makeQuestionsModelHappy() {
        const adminstate = snapstate({
            access: undefined,
            users: [],
            questions: [],
            boardOps: {},
            postingOp: ops.ready(undefined),
        });
        const state = adminstate.writable;
        const actions = {
            setAccess(access) {
                state.access = access;
            },
            setBoardOp(board, op) {
                state.boardOps = { ...state.boardOps, [board]: op };
            },
            setPostingOp(op) {
                state.postingOp = op;
            },
            addUsers(newUsers) {
                state.users = [...merge(newUsers.filter(u => !!u), state.users, (a, b) => a.userId === b.userId)];
            },
            addQuestions(newQuestions) {
                state.questions = [...merge(newQuestions, state.questions, (a, b) => a.questionId === b.questionId)];
            },
            addAnswer(newAnswer) {
                const question = state.questions
                    .find(q => q.questionId === newAnswer.questionId);
                if (!question)
                    throw new Error(`can't find question to add answer, question id: "${newAnswer.questionId}"`);
                const newQuestion = {
                    ...question,
                    answers: [...question.answers, newAnswer],
                };
                state.questions = [...merge([newQuestion], state.questions, (a, b) => a.questionId === b.questionId)];
            },
            setQuestionLike(questionId, like) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        liked: like,
                        likes: question.liked === like
                            ? question.likes
                            : like
                                ? question.likes + 1
                                : question.likes - 1
                    }
                    : { ...question });
            },
            setAnswerLike(questionId, answerId, status) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        answers: question.answers.map(answer => answer.answerId === answerId
                            ? {
                                ...answer,
                                liked: status,
                                likes: answer.liked === status
                                    ? answer.likes
                                    : status
                                        ? answer.likes + 1
                                        : answer.likes - 1
                            }
                            : { ...answer })
                    }
                    : { ...question });
            },
            setAnswerReport(questionId, answerId, status) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        answers: question.answers.map(answer => answer.answerId === answerId
                            ? {
                                ...answer,
                                reported: status,
                                reports: answer.reported === status
                                    ? answer.reports
                                    : status
                                        ? answer.reports + 1
                                        : answer.reports - 1
                            }
                            : { ...answer })
                    }
                    : { ...question });
            },
            setQuestionReport(questionId, report) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        reported: report,
                        reports: question.reported === report
                            ? question.reports
                            : report
                                ? question.reports + 1
                                : question.reports - 1
                    }
                    : { ...question });
            },
            setQuestionArchive(questionId, archive) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? { ...question, archive }
                    : { ...question });
            },
            setAnswerArchive(questionId, answerId, archive) {
                state.questions = state.questions.map(question => question.questionId === questionId
                    ? {
                        ...question,
                        answers: question.answers.map(answer => answer.answerId === answerId
                            ? { ...answer, archive }
                            : { ...answer })
                    }
                    : { ...question });
            },
        };
        return {
            actions,
            state: adminstate.readable,
            subscribe: adminstate.subscribe,
        };
    }

    function prepareQuestionsBoardModelGetter({ state, actions, questionsPostingService, questionsAnsweringService, questionsModerationService, getAccess, loadQuestionsForBoard, }) {
        return (board) => ({
            getPermissions() {
                const { access } = state;
                return {
                    "read questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["read questions"])
                        : false,
                    "post questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["post questions"]) && !access.permit.privileges.includes(appPermissions.privileges["banned"])
                        : false,
                    "moderate questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["moderate questions"])
                        : false,
                    "answer questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["answer questions"])
                        : false,
                    "like questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["like questions"])
                        : false,
                    "report questions": access
                        ? access.permit.privileges.includes(appPermissions.privileges["report questions"])
                        : false,
                };
            },
            getBoardName() {
                return board;
            },
            getAccess() {
                return state.access;
            },
            getBoardOp() {
                return state.boardOps[board];
            },
            getPostingOp() {
                return state.postingOp;
            },
            getQuestions() {
                return state.questions
                    .filter(question => question.board === board)
                    .filter(question => question.archive === false)
                    .map(question => ({
                    ...question,
                    answers: question.answers
                        .filter(answer => answer.archive === false)
                }));
            },
            getUser(userId) {
                return state.users.find(user => user.userId === userId);
            },
            async loadQuestions() {
                await loadQuestionsForBoard(board);
            },
            async postQuestion({ content }) {
                const question = await ops.operation({
                    promise: questionsPostingService.postQuestion({
                        questionDraft: { board, content }
                    }),
                    setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                });
                actions.addQuestions([question]);
                const access = ops.value(getAccess());
                actions.addUsers([access.user]);
                return question;
            },
            async postAnswer(questionId, answerDraft) {
                const answer = await ops.operation({
                    promise: questionsAnsweringService.postAnswer({
                        questionId,
                        answerDraft,
                    }),
                    setOp: op => actions.setPostingOp(ops.replaceValue(op, undefined)),
                });
                actions.addAnswer(answer);
                const access = ops.value(getAccess());
                actions.addUsers([access.user]);
                return answer;
            },
            async likeQuestion(questionId, like) {
                await questionsPostingService.likeQuestion({
                    like: like,
                    questionId,
                });
                actions.setQuestionLike(questionId, like);
            },
            async likeAnswer(questionId, answerId, like) {
                await questionsAnsweringService.likeAnswer({ answerId, like });
                actions.setAnswerLike(questionId, answerId, like);
            },
            async reportQuestion(questionId, report) {
                await questionsPostingService.reportQuestion({
                    report,
                    questionId,
                });
                actions.setQuestionReport(questionId, report);
            },
            async reportAnswer(questionId, answerId, report) {
                await questionsAnsweringService.reportAnswer({ answerId, report });
                actions.setAnswerReport(questionId, answerId, report);
            },
            async archiveQuestion(questionId, archive) {
                await questionsPostingService.archiveQuestion({
                    archive,
                    questionId,
                });
                actions.setQuestionArchive(questionId, archive);
            },
            async archiveAnswer(questionId, answerId, archive) {
                await questionsAnsweringService.archiveAnswer({ answerId, archive });
                actions.setAnswerArchive(questionId, answerId, archive);
            },
            async archiveBoard() {
                await questionsModerationService.archiveBoard({ board });
                for (const question of state.questions)
                    actions.setQuestionArchive(question.questionId, true);
            },
        });
    }

    function makeQuestionsModel(options) {
        const { questionsReadingService } = options;
        const { state, actions, subscribe } = makeQuestionsModelHappy();
        async function loadQuestionsForBoard(board) {
            await ops.operation({
                promise: (async () => {
                    const { users, questions } = await questionsReadingService
                        .fetchQuestions({ board });
                    actions.addUsers(users);
                    actions.addQuestions(questions);
                })(),
                setOp: op => actions.setBoardOp(board, op),
            });
        }
        async function refreshAllBoards() {
            await Promise.all(Object.keys(state.boardOps).map(loadQuestionsForBoard));
        }
        return {
            subscribe,
            makeBoardModel: prepareQuestionsBoardModelGetter({
                state,
                actions,
                loadQuestionsForBoard,
                ...options,
            }),
            accessChange: (access) => {
                actions.setAccess(access);
                if (access === null || access === void 0 ? void 0 : access.user)
                    actions.addUsers([access.user]);
                refreshAllBoards();
            },
        };
    }

    class AccessError extends Error {
    }
    class AccessLoginExpiredError extends AccessError {
        constructor() {
            super("login token has expired");
        }
    }

    function makeAccessModel({ authMediator, loginService }) {
        const state = snapstate({
            accessOp: ops.none(),
        });
        authMediator.subscribeToAccessChange(access => {
            state.writable.accessOp = ops.ready(access);
        });
        async function accessOperation(promise) {
            return ops.operation({
                promise,
                setOp: op => state.writable.accessOp = op,
            });
        }
        const loginFacilities = {
            async useExistingLogin() {
                await accessOperation(authMediator.initialize());
            },
            async sendLoginLink(email) {
                return loginService.sendLoginLink({ email });
            },
            async login(loginToken) {
                try {
                    if (isTokenValid(loginToken))
                        await accessOperation(loginService
                            .authenticateViaLoginToken({ loginToken })
                            .then(tokens => authMediator.login(tokens)));
                    else
                        throw new AccessLoginExpiredError();
                }
                catch (error) {
                    console.error(error);
                    state.writable.accessOp = ops.none();
                    await accessOperation(authMediator.initialize());
                    throw error;
                }
            },
            async logout() {
                await ops.operation({
                    promise: authMediator.logout(),
                    setOp: op => state.writable.accessOp = op,
                });
            },
            async reauthorize() {
                await accessOperation(authMediator.reauthorize());
            },
        };
        return {
            readable: state.readable,
            track: state.track,
            subscribe: state.subscribe,
            ...loginFacilities,
            getAccessOp() {
                return state.readable.accessOp;
            },
            getAccess() {
                return ops.value(state.readable.accessOp);
            },
            getValidAccess() {
                return authMediator.getValidAccess();
            },
        };
    }

    function makePersonalModel({ personalService, getAccessOp, reauthorize, }) {
        const { readable, writable, track, subscribe } = snapstate({
            accessOp: getAccessOp(),
            submitDraftOp: ops.ready(undefined),
        });
        return {
            track,
            subscribe,
            readable,
            async saveProfile(profileDraft) {
                await ops.operation({
                    promise: (async () => {
                        const { user: { userId } } = ops.value(readable.accessOp);
                        await personalService.setProfile({ userId, profileDraft });
                        await reauthorize();
                    })(),
                    errorReason: "error saving profile",
                    setOp(op) { writable.submitDraftOp = op; },
                });
            },
            updateAccessOp(op) {
                writable.accessOp = op;
            },
        };
    }

    function makeAllowanceChecker(access, privileges) {
        const allowed = {};
        for (const [key, privilegeId] of Object.entries(privileges))
            allowed[key] = access
                ? access.permit.privileges.includes(privilegeId)
                : false;
        return (privilege) => allowed[privilege];
    }

    function makeAdministrativeModel({ roleAssignmentService, reauthorize, }) {
        const state = snapstate({
            accessOp: ops.none(),
            permissionsOp: ops.none(),
        });
        function getAccess() {
            return ops.value(state.readable.accessOp);
        }
        let initializedInDom = false;
        function allowanceChecker() {
            return makeAllowanceChecker(getAccess(), appPermissions.privileges);
        }
        async function loadPermissions() {
            if (initializedInDom && allowanceChecker()("administrate user roles"))
                await ops.operation({
                    promise: roleAssignmentService.fetchPermissions(),
                    setOp: op => state.writable.permissionsOp = op,
                });
        }
        async function initialize() {
            initializedInDom = true;
            await loadPermissions();
        }
        return {
            state: state.readable,
            subscribe: state.subscribe,
            getAccess,
            initialize,
            get isAllowed() {
                return allowanceChecker();
            },
            reauthorize,
            searchUsers: roleAssignmentService.searchUsers,
            assignRoleToUser: roleAssignmentService.assignRoleToUser,
            revokeRoleFromUser: roleAssignmentService.revokeRoleFromUser,
            async updateAccessOp(op) {
                state.writable.accessOp = op;
                loadPermissions();
            },
        };
    }

    function makePermissionsModel({ permissionsService, reauthorize, }) {
        const { readable, writable, subscribe, track } = snapstate({
            active: false,
            accessOp: ops.none(),
            permissionsDisplay: ops.none(),
        });
        function getAccess() {
            return ops.value(readable.accessOp);
        }
        function sortPermissions(permissions) {
            const softPrivileges = [];
            const hardPrivileges = [];
            for (const privilege of permissions.privileges) {
                if (privilege.hard)
                    hardPrivileges.push(privilege);
                else
                    softPrivileges.push(privilege);
            }
            softPrivileges.sort((a, b) => b.time - a.time);
            return {
                ...permissions,
                privileges: [...softPrivileges, ...hardPrivileges],
            };
        }
        async function reload() {
            await ops.operation({
                promise: Promise.resolve()
                    .then(async () => getUserCanCustomizePermissions()
                    ? permissionsService.fetchPermissions().then(sortPermissions)
                    : undefined),
                setOp: op => writable.permissionsDisplay = op,
            });
        }
        function getUserCanCustomizePermissions() {
            const access = getAccess();
            return (access === null || access === void 0 ? void 0 : access.user)
                ? access.permit.privileges.includes(appPermissions.privileges["customize permissions"])
                : false;
        }
        async function initialize() {
            writable.active = true;
            if (getUserCanCustomizePermissions())
                await reload();
        }
        function reloadAfter(func) {
            return (async (...args) => {
                const result = await func(...args);
                await reload();
                await reauthorize();
                return result;
            });
        }
        return {
            readable,
            subscribe,
            track,
            getAccess,
            initialize,
            getUserCanCustomizePermissions,
            createRole: reloadAfter(permissionsService.createRole),
            deleteRole: reloadAfter(permissionsService.deleteRole),
            assignPrivilege: reloadAfter(permissionsService.assignPrivilege),
            unassignPrivilege: reloadAfter(permissionsService.unassignPrivilege),
            deletePrivilege: reloadAfter(permissionsService.deletePrivilege),
            createPrivilege: reloadAfter(permissionsService.createPrivilege),
            async updateAccessOp(op) {
                writable.accessOp = op;
                const access = getAccess();
                if ((access === null || access === void 0 ? void 0 : access.user) && writable.active)
                    await reload();
            },
        };
    }

    async function assembleModels({ appId, remote, popups, storage, authMediator, chatConnect, }) {
        const accessModel = makeAccessModel({
            authMediator,
            loginService: remote.auth.users.loginService,
        });
        const { getAccessOp, getAccess, getValidAccess, reauthorize } = accessModel;
        const exampleModel = makeExampleModel({ getAccessOp });
        const personalModel = makePersonalModel({
            personalService: remote.auth.users.personalService,
            getAccessOp,
            reauthorize,
        });
        const appsModel = makeAppsModel({
            appService: remote.auth.apps.appService,
            appEditService: remote.auth.apps.appEditService,
            getValidAccess,
        });
        const permissionsModel = makePermissionsModel({
            permissionsService: remote.auth.permissions.permissionsService,
            reauthorize,
        });
        const videoModels = makeVideoModels({
            dacastService: remote.videos.dacastService,
            contentService: remote.videos.contentService,
        });
        const chatModel = makeChatModel({
            chatConnect,
            getChatMeta: async () => ({
                accessToken: await authMediator.getValidAccessToken(),
            }),
        });
        const notesModel = makeNotesModel({
            notesService: remote.notes.notesService,
        });
        // // TODO reactivate store
        // const storeModel = makeStoreModel({
        // 	appId,
        // 	storage,
        // 	shopkeepingService: remote.store.shopkeepingService,
        // 	stripeAccountsService: remote.store.stripeConnectService,
        // 	statusCheckerService: remote.store.ecommerce.statusCheckerService,
        // 	statusTogglerService: remote.store.ecommerce.statusTogglerService,
        // 	triggerBankPopup: popups.triggerBankPopup,
        // })
        const administrativeModel = makeAdministrativeModel({
            roleAssignmentService: remote.administrative.roleAssignmentService,
            reauthorize: () => accessModel.reauthorize(),
        });
        const questionsModel = makeQuestionsModel({
            ...remote.questions,
            getAccess: getAccessOp,
        });
        accessModel.subscribe(async ({ accessOp }) => {
            const access = getAccess();
            await Promise.all([
                exampleModel.updateAccessOp(accessOp),
                personalModel.updateAccessOp(accessOp),
                appsModel.updateAccessOp(accessOp),
                permissionsModel.updateAccessOp(accessOp),
                questionsModel.accessChange(access),
                administrativeModel.updateAccessOp(accessOp),
                videoModels.dacastModel.updateAccessOp(accessOp),
                videoModels.contentModel.updateAccessOp(accessOp),
                chatModel.updateAccessOp(accessOp),
                notesModel.updateAccessOp(accessOp),
                // storeModel.accessChange(access),
            ]);
        });
        return {
            exampleModel,
            appsModel,
            chatModel,
            accessModel,
            videoModels,
            notesModel,
            // storeModel,
            personalModel,
            questionsModel,
            permissionsModel,
            administrativeModel,
        };
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const t$1=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,e$3=Symbol(),n$4=new Map;class s$3{constructor(t,n){if(this._$cssResult$=!0,n!==e$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t;}get styleSheet(){let e=n$4.get(this.cssText);return t$1&&void 0===e&&(n$4.set(this.cssText,e=new CSSStyleSheet),e.replaceSync(this.cssText)),e}toString(){return this.cssText}}const o$4=t=>new s$3("string"==typeof t?t:t+"",e$3),r$2=(t,...n)=>{const o=1===t.length?t[0]:n.reduce(((e,n,s)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(n)+t[s+1]),t[0]);return new s$3(o,e$3)},i$3=(e,n)=>{t$1?e.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((t=>{const n=document.createElement("style"),s=window.litNonce;void 0!==s&&n.setAttribute("nonce",s),n.textContent=t.cssText,e.appendChild(n);}));},S$1=t$1?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const n of t.cssRules)e+=n.cssText;return o$4(e)})(t):t;

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var s$2;const e$2=window.trustedTypes,r$1=e$2?e$2.emptyScript:"",h$1=window.reactiveElementPolyfillSupport,o$3={toAttribute(t,i){switch(i){case Boolean:t=t?r$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},n$3=(t,i)=>i!==t&&(i==i||t==t),l$2={attribute:!0,type:String,converter:o$3,reflect:!1,hasChanged:n$3};class a$1 extends HTMLElement{constructor(){super(),this._$Et=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Ei=null,this.o();}static addInitializer(t){var i;null!==(i=this.l)&&void 0!==i||(this.l=[]),this.l.push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Eh(s,i);void 0!==e&&(this._$Eu.set(e,s),t.push(e));})),t}static createProperty(t,i=l$2){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$2}static finalize(){if(this.hasOwnProperty("finalized"))return !1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this._$Eu=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(S$1(i));}else void 0!==i&&s.push(S$1(i));return s}static _$Eh(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}o(){var t;this._$Ep=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Em(),this.requestUpdate(),null===(t=this.constructor.l)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$Eg)&&void 0!==i?i:this._$Eg=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$Eg)||void 0===i||i.splice(this._$Eg.indexOf(t)>>>0,1);}_$Em(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Et.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return i$3(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$ES(t,i,s=l$2){var e,r;const h=this.constructor._$Eh(t,s);if(void 0!==h&&!0===s.reflect){const n=(null!==(r=null===(e=s.converter)||void 0===e?void 0:e.toAttribute)&&void 0!==r?r:o$3.toAttribute)(i,s.type);this._$Ei=t,null==n?this.removeAttribute(h):this.setAttribute(h,n),this._$Ei=null;}}_$AK(t,i){var s,e,r;const h=this.constructor,n=h._$Eu.get(t);if(void 0!==n&&this._$Ei!==n){const t=h.getPropertyOptions(n),l=t.converter,a=null!==(r=null!==(e=null===(s=l)||void 0===s?void 0:s.fromAttribute)&&void 0!==e?e:"function"==typeof l?l:null)&&void 0!==r?r:o$3.fromAttribute;this._$Ei=n,this[n]=a(i,t.type),this._$Ei=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||n$3)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$Ei!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$Ep=this._$E_());}async _$E_(){this.isUpdatePending=!0;try{await this._$Ep;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Et&&(this._$Et.forEach(((t,i)=>this[i]=t)),this._$Et=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$EU();}catch(t){throw i=!1,this._$EU(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$Eg)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Ep}shouldUpdate(t){return !0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$ES(i,this[i],t))),this._$EC=void 0),this._$EU();}updated(t){}firstUpdated(t){}}a$1.finalized=!0,a$1.elementProperties=new Map,a$1.elementStyles=[],a$1.shadowRootOptions={mode:"open"},null==h$1||h$1({ReactiveElement:a$1}),(null!==(s$2=globalThis.reactiveElementVersions)&&void 0!==s$2?s$2:globalThis.reactiveElementVersions=[]).push("1.3.0");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var t;const i$2=globalThis.trustedTypes,s$1=i$2?i$2.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$1=`lit$${(Math.random()+"").slice(9)}$`,o$2="?"+e$1,n$2=`<${o$2}>`,l$1=document,h=(t="")=>l$1.createComment(t),r=t=>null===t||"object"!=typeof t&&"function"!=typeof t,d=Array.isArray,u=t=>{var i;return d(t)||"function"==typeof(null===(i=t)||void 0===i?void 0:i[Symbol.iterator])},c=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,a=/>/g,f=/>|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,_=/'/g,m=/"/g,g=/^(?:script|style|textarea|title)$/i,p=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),$=p(1),y=p(2),b=Symbol.for("lit-noChange"),w=Symbol.for("lit-nothing"),T=new WeakMap,x=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new N(i.insertBefore(h(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l},A=l$1.createTreeWalker(l$1,129,null,!1),C=(t,i)=>{const o=t.length-1,l=[];let h,r=2===i?"<svg>":"",d=c;for(let i=0;i<o;i++){const s=t[i];let o,u,p=-1,$=0;for(;$<s.length&&(d.lastIndex=$,u=d.exec(s),null!==u);)$=d.lastIndex,d===c?"!--"===u[1]?d=v:void 0!==u[1]?d=a:void 0!==u[2]?(g.test(u[2])&&(h=RegExp("</"+u[2],"g")),d=f):void 0!==u[3]&&(d=f):d===f?">"===u[0]?(d=null!=h?h:c,p=-1):void 0===u[1]?p=-2:(p=d.lastIndex-u[2].length,o=u[1],d=void 0===u[3]?f:'"'===u[3]?m:_):d===m||d===_?d=f:d===v||d===a?d=c:(d=f,h=void 0);const y=d===f&&t[i+1].startsWith("/>")?" ":"";r+=d===c?s+n$2:p>=0?(l.push(o),s.slice(0,p)+"$lit$"+s.slice(p)+e$1+y):s+e$1+(-2===p?(l.push(void 0),i):y);}const u=r+(t[o]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return [void 0!==s$1?s$1.createHTML(u):u,l]};class E{constructor({strings:t,_$litType$:s},n){let l;this.parts=[];let r=0,d=0;const u=t.length-1,c=this.parts,[v,a]=C(t,s);if(this.el=E.createElement(v,n),A.currentNode=this.el.content,2===s){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(l=A.nextNode())&&c.length<u;){if(1===l.nodeType){if(l.hasAttributes()){const t=[];for(const i of l.getAttributeNames())if(i.endsWith("$lit$")||i.startsWith(e$1)){const s=a[d++];if(t.push(i),void 0!==s){const t=l.getAttribute(s.toLowerCase()+"$lit$").split(e$1),i=/([.?@])?(.*)/.exec(s);c.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?M:"?"===i[1]?H:"@"===i[1]?I:S});}else c.push({type:6,index:r});}for(const i of t)l.removeAttribute(i);}if(g.test(l.tagName)){const t=l.textContent.split(e$1),s=t.length-1;if(s>0){l.textContent=i$2?i$2.emptyScript:"";for(let i=0;i<s;i++)l.append(t[i],h()),A.nextNode(),c.push({type:2,index:++r});l.append(t[s],h());}}}else if(8===l.nodeType)if(l.data===o$2)c.push({type:2,index:r});else {let t=-1;for(;-1!==(t=l.data.indexOf(e$1,t+1));)c.push({type:7,index:r}),t+=e$1.length-1;}r++;}}static createElement(t,i){const s=l$1.createElement("template");return s.innerHTML=t,s}}function P(t,i,s=t,e){var o,n,l,h;if(i===b)return i;let d=void 0!==e?null===(o=s._$Cl)||void 0===o?void 0:o[e]:s._$Cu;const u=r(i)?void 0:i._$litDirective$;return (null==d?void 0:d.constructor)!==u&&(null===(n=null==d?void 0:d._$AO)||void 0===n||n.call(d,!1),void 0===u?d=void 0:(d=new u(t),d._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Cl)&&void 0!==l?l:h._$Cl=[])[e]=d:s._$Cu=d),void 0!==d&&(i=P(t,d._$AS(t,i.values),d,e)),i}class V{constructor(t,i){this.v=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}p(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:l$1).importNode(s,!0);A.currentNode=o;let n=A.nextNode(),h=0,r=0,d=e[0];for(;void 0!==d;){if(h===d.index){let i;2===d.type?i=new N(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new L(n,this,t)),this.v.push(i),d=e[++r];}h!==(null==d?void 0:d.index)&&(n=A.nextNode(),h++);}return o}m(t){let i=0;for(const s of this.v)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class N{constructor(t,i,s,e){var o;this.type=2,this._$AH=w,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cg=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cg}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=P(this,t,i),r(t)?t===w||null==t||""===t?(this._$AH!==w&&this._$AR(),this._$AH=w):t!==this._$AH&&t!==b&&this.$(t):void 0!==t._$litType$?this.T(t):void 0!==t.nodeType?this.k(t):u(t)?this.S(t):this.$(t);}A(t,i=this._$AB){return this._$AA.parentNode.insertBefore(t,i)}k(t){this._$AH!==t&&(this._$AR(),this._$AH=this.A(t));}$(t){this._$AH!==w&&r(this._$AH)?this._$AA.nextSibling.data=t:this.k(l$1.createTextNode(t)),this._$AH=t;}T(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=E.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.m(s);else {const t=new V(o,this),i=t.p(this.options);t.m(s),this.k(i),this._$AH=t;}}_$AC(t){let i=T.get(t.strings);return void 0===i&&T.set(t.strings,i=new E(t)),i}S(t){d(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new N(this.A(h()),this.A(h()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cg=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class S{constructor(t,i,s,e,o){this.type=1,this._$AH=w,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=w;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=P(this,t,i,0),n=!r(t)||t!==this._$AH&&t!==b,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=P(this,e[s+l],i,l),h===b&&(h=this._$AH[l]),n||(n=!r(h)||h!==this._$AH[l]),h===w?t=w:t!==w&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.C(t);}C(t){t===w?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class M extends S{constructor(){super(...arguments),this.type=3;}C(t){this.element[this.name]=t===w?void 0:t;}}const k=i$2?i$2.emptyScript:"";class H extends S{constructor(){super(...arguments),this.type=4;}C(t){t&&t!==w?this.element.setAttribute(this.name,k):this.element.removeAttribute(this.name);}}class I extends S{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=P(this,t,i,0))&&void 0!==s?s:w)===b)return;const e=this._$AH,o=t===w&&e!==w||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==w&&(e===w||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){P(this,t);}}const z=window.litHtmlPolyfillSupport;null==z||z(E,N),(null!==(t=globalThis.litHtmlVersions)&&void 0!==t?t:globalThis.litHtmlVersions=[]).push("2.2.0");

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var l,o$1;class s extends a$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Dt=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Dt=x(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!1);}render(){return b}}s.finalized=!0,s._$litElement$=!0,null===(l=globalThis.litElementHydrateSupport)||void 0===l||l.call(globalThis,{LitElement:s});const n$1=globalThis.litElementPolyfillSupport;null==n$1||n$1({LitElement:s});(null!==(o$1=globalThis.litElementVersions)&&void 0!==o$1?o$1:globalThis.litElementVersions=[]).push("3.2.0");

    function mixinInitiallyHidden(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                if (this.hasAttribute("initially-hidden"))
                    this.removeAttribute("initially-hidden");
            }
        };
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const i$1=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}};function e(e){return (n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i);})(e,n,t):i$1(e,n)}

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */
    const o=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:"method",placement:"prototype",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n);}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n);}};

    /**
     * @license
     * Copyright 2017 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */function i(i,n){return o({descriptor:o=>{const t={get(){var o,n;return null!==(n=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==n?n:null},enumerable:!0,configurable:!0};if(n){const n="symbol"==typeof o?Symbol():"__"+o;t.get=function(){var o,t;return void 0===this[n]&&(this[n]=null!==(t=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==t?t:null),this[n]};}return t}})}

    /**
     * @license
     * Copyright 2021 Google LLC
     * SPDX-License-Identifier: BSD-3-Clause
     */var n;null!=(null===(n=window.HTMLSlotElement)||void 0===n?void 0:n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));

    function arrayize(item) {
        return [item].flat();
    }
    const notUndefined = (x) => x !== undefined;
    function combineStyles(parentStyles, newStyles) {
        var _a;
        const styles = [
            ...((_a = arrayize(parentStyles)) !== null && _a !== void 0 ? _a : []),
            ...arrayize(newStyles),
        ];
        return styles
            .flat()
            .filter(notUndefined);
    }
    function mixinStyles(...newStyles) {
        return function (Base) {
            var _a;
            return _a = class extends Base {
                },
                _a.styles = combineStyles(Base.styles, newStyles),
                _a;
        };
    }

    function objectMap(input, mapper) {
        const output = {};
        for (const [key, value] of Object.entries(input))
            output[key] = mapper(value, key);
        return output;
    }

    const themeComponents = (theme, components) => {
        return objectMap(components, Component => mixinStyles(theme)(Component));
    };

    /**
     * Convert a camel-case name into a dashed name
     * - for example
     *       dashify("BigManStyle")
     *       //> "big-man-style"
     */
    function dashify(camel) {
        return camel.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
    }

    function registerComponents(components) {
        for (const [name, component] of Object.entries(components))
            customElements.define(dashify(name), component);
    }

    function mixinFocusable(Base) {
        return class extends Base {
            connectedCallback() {
                super.connectedCallback();
                this.setAttribute("focusable", "");
            }
        };
    }

    var __classPrivateFieldGet$e = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$9 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    function mixinSnapstateSubscriptions(...subscribes) {
        return function (Base) {
            var _unsubscribes, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _unsubscribes.set(this, []);
                    }
                    connectedCallback() {
                        super.connectedCallback();
                        const update = () => { this.requestUpdate(); };
                        __classPrivateFieldSet$9(this, _unsubscribes, subscribes.map(subscribe => subscribe(update)), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        for (const unsubscribe of __classPrivateFieldGet$e(this, _unsubscribes, "f"))
                            unsubscribe();
                        __classPrivateFieldSet$9(this, _unsubscribes, [], "f");
                    }
                },
                _unsubscribes = new WeakMap(),
                _a;
        };
    }

    function mixinShare(providedShare) {
        return function (Base) {
            return class extends Base {
                get share() {
                    return providedShare;
                }
            };
        };
    }
    function mixinRequireShare(name) {
        return function (Base) {
            return class extends Base {
                get share() {
                    throw new Error(`share required by component${name ? " " + name : ""}`);
                }
            };
        };
    }

    var __classPrivateFieldSet$8 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$d = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    function mixinTicker(period) {
        return function (Base) {
            var _interval, _a;
            return _a = class extends Base {
                    constructor() {
                        super(...arguments);
                        _interval.set(this, void 0);
                    }
                    tick() { }
                    connectedCallback() {
                        super.connectedCallback();
                        __classPrivateFieldSet$8(this, _interval, setInterval(() => {
                            this.tick();
                            this.requestUpdate();
                        }, period), "f");
                    }
                    disconnectedCallback() {
                        super.disconnectedCallback();
                        clearInterval(__classPrivateFieldGet$d(this, _interval, "f"));
                    }
                },
                _interval = new WeakMap(),
                _a;
        };
    }

    var __classPrivateFieldGet$c = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$7 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _Component_subscriptions, _Component_unsubscribe;
    class Component extends mixinInitiallyHidden(s) {
        constructor() {
            super(...arguments);
            _Component_subscriptions.set(this, []);
            _Component_unsubscribe.set(this, () => { });
        }
        init() { }
        firstUpdated(changes) {
            super.firstUpdated(changes);
            this.init();
        }
        addSubscription(subscribe) {
            __classPrivateFieldGet$c(this, _Component_subscriptions, "f").push(subscribe);
        }
        subscribe() {
            const unsubscribes = __classPrivateFieldGet$c(this, _Component_subscriptions, "f").map(s => s());
            return () => unsubscribes.forEach(u => u());
        }
        connectedCallback() {
            super.connectedCallback();
            __classPrivateFieldSet$7(this, _Component_unsubscribe, this.subscribe(), "f");
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            __classPrivateFieldGet$c(this, _Component_unsubscribe, "f").call(this);
            __classPrivateFieldSet$7(this, _Component_unsubscribe, () => { }, "f");
        }
        render() {
            throw new Error("component render method not implemented");
        }
    }
    _Component_subscriptions = new WeakMap(), _Component_unsubscribe = new WeakMap();

    var theme = r$2 `

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

*:focus {
	outline: var(--focus-outline, 3px solid cyan);
}

`;

    var styles$m = r$2 `

:host {
	display: inline-block;
	position: relative;
	width: 6em;
}

:host::before {
	opacity: 0;
	content: "copied!";
	display: block;
	position: absolute;
	top: -0.5em;
	right: -0.5em;
	background: #0a0c;
	padding: 0 0.5em;
	border-radius: 1em;
	pointer-events: none;
	z-index: 1;
}

:host(:not([copied]))::before {
	transition: opacity 500ms ease;
}

:host([copied])::before {
	opacity: 1;
}

button {
	font: inherit;
	color: inherit;
	background: transparent;
	width: 100%;
}

.container {
	position: relative;
	display: flex;
	flex-direction: row;
	user-select: none;
	cursor: pointer;
	border: none;
}

.content {
	display: flex;
	justify-content: row;
}

.label::after {
	content: ":";
	margin-right: 0.2em;
}

.id {
	opacity: 0.75;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
}

.copy svg {
	width: 1em;
	height: 1em;
}

.copy {
	opacity: 0.4;
	transition: opacity 100ms linear;
}

.container:hover .copy {
	opacity: 0.9;
}

.container:active .copy {
	opacity: 1;
}

`;

    var clipboardIcon = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clipboard"><path d="M16 4h2a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V6a2 2 0 012-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>`;

    var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioId = class XioId extends Component {
        constructor() {
            super(...arguments);
            this.copied = false;
        }
        async copy() {
            try {
                await navigator.clipboard.writeText(this.id);
                const activeElement = document.activeElement;
                if (activeElement)
                    activeElement.blur();
                if (this.copyTimeout) {
                    clearTimeout(this.copyTimeout);
                }
                this.copied = true;
                this.copyTimeout = setTimeout(() => {
                    this.copied = false;
                    this.copyTimeout = undefined;
                }, 1000);
            }
            catch (error) {
                console.error("failed to copy");
            }
        }
        render() {
            return $ `
			<button class=container @click=${this.copy}>
				<div class=id>${this.id}</div>
				<div class=copy>
					${clipboardIcon}
				</div>
			</button>
		`;
        }
    };
    __decorate$q([
        e()
    ], XioId.prototype, "id", void 0);
    __decorate$q([
        e({ type: Boolean, reflect: true })
    ], XioId.prototype, "copied", void 0);
    XioId = __decorate$q([
        mixinFocusable,
        mixinStyles(styles$m)
    ], XioId);

    var styles$l = r$2 `

slot {
	vertical-align: middle;
}

svg, span {
	display: inline-block;
	vertical-align: middle;
}

svg {
	width: var(--op-size, 1.2em);
	height: var(--op-size, 1.2em);
}

slot[name=loading] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

slot[name=error] * {
	color: var(--loading-error-color, red);
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    var warningSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M10 7a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4A.5.5 0 0 1 10 7z" fill="#626262"/><path d="M10 14.5a.75.75 0 1 0 0-1.5a.75.75 0 0 0 0 1.5z" fill="#626262"/><path d="M8.686 2.852a1.5 1.5 0 0 1 2.628 0l6.56 11.925A1.5 1.5 0 0 1 16.558 17H3.44a1.5 1.5 0 0 1-1.314-2.223L8.686 2.852zm1.752.482a.5.5 0 0 0-.876 0L3.003 15.26a.5.5 0 0 0 .438.741H16.56a.5.5 0 0 0 .438-.74L10.438 3.333z" fill="currentColor"/></g></svg>`;

    var spinnerIcon = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-loader"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>`;

    var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioOp = class XioOp extends Component {
        constructor() {
            super(...arguments);
            this.mode = "none";
            this._op = ops.none();
            this.errorIcon = warningSvg;
            this.loadingIcon = spinnerIcon;
            this["loading-message"] = "";
            this["error-message"] = "error";
            this["show-error-text"] = true;
        }
        get op() {
            return this._op;
        }
        set op(op) {
            const old = this._op;
            this._op = op;
            this.mode = ops.mode(op);
            this.requestUpdate("op", old);
        }
        firstUpdated() {
            if (this["start-loading"]) {
                this.op = ops.loading();
            }
        }
        render() {
            return ops.select(this.op, {
                none: () => $ `
				<slot name=none></slot>
			`,
                loading: () => $ `
				<slot name=loading>
					${this.loadingIcon}
					${this["loading-message"]
                ? $ `<span>${this["loading-message"]}</span>`
                : null}
				</slot>
			`,
                error: reason => $ `
				<slot name=error>
					${this.errorIcon}
					${this["show-error-text"]
                ? $ `<span>${reason !== null && reason !== void 0 ? reason : this["error-message"]}</span>`
                : null}
					
				</slot>
			`,
                ready: () => $ `
				<slot></slot>
			`,
            });
        }
    };
    __decorate$p([
        e({ type: String, reflect: true })
    ], XioOp.prototype, "mode", void 0);
    __decorate$p([
        e({ type: Object })
    ], XioOp.prototype, "op", null);
    __decorate$p([
        e()
    ], XioOp.prototype, "errorIcon", void 0);
    __decorate$p([
        e()
    ], XioOp.prototype, "loadingIcon", void 0);
    __decorate$p([
        e({ type: String })
    ], XioOp.prototype, "loading-message", void 0);
    __decorate$p([
        e({ type: String })
    ], XioOp.prototype, "error-message", void 0);
    __decorate$p([
        e({ type: Boolean })
    ], XioOp.prototype, "show-error-text", void 0);
    __decorate$p([
        e({ type: Boolean })
    ], XioOp.prototype, "start-loading", void 0);
    XioOp = __decorate$p([
        mixinStyles(styles$l)
    ], XioOp);

    function getAssignedElements(slot) {
        return Array.from(slot.assignedNodes())
            .filter(node => node instanceof HTMLElement);
    }

    var xioMenuItemCss = r$2 `

:host {
	display: block;
	width: 2em;
	height: 2em;
}

:host([theme="concrete"]) [part="button"] {
	display: block;
	font-size: inherit;
	color: inherit;
	position: relative;
	padding: 0;
	border: none;
	background: transparent;
	width: 100%;
	height: 100%;
}

:host([theme="concrete"]) [part="buttoncontent"] {
	display: flex;
	width: 100%;
	height: 100%;
	justify-content: center;
	align-items: center;
}

:host([theme="concrete"]) [part="buttoncontent"] {
	transform: scale(1);
	transition: transform 100ms ease;
}

:host([theme="concrete"]) [part="buttoncontent"]:active {
	transform: scale(1.1);
}

[part="panel"] {
	display: none;
}

:host([open]) [part="panel"] {
	display: block;
}

:host([theme="concrete"]) [part="panel"] {
	position: absolute;
	left: var(--menu-lanesize, 1rem);
	right: var(--menu-lanesize, 1rem);
	width: var(--menu-panel-width, 640px);
	max-width: calc(100% - calc(var(--menu-lanesize, 1rem) * 2));
	margin-top: var(--menu-padding, 0.15rem);
	margin-left: auto;
	padding: var(--menu-panel-padding, 1rem);
	background: var(--menu-panel-background, white);
	border-radius: var(--menu-panel-border-radius, 0);
	box-shadow: var(--menu-panel-box-shadow, none);
	backdrop-filter: var(--menu-panel-backdrop-filter, none);
	--webkit-backdrop-filter: var(--menu-panel-backdrop-filter, none);
}

:host([theme="concrete"][sticky]) [part="panel"] {
	top: 100%;
}

:host([theme="concrete"][lefty]) [part="panel"] {
	margin-left: unset;
	margin-right: auto;
}

`;

    var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$b = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$6 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XioMenuItem_hasPanel, _XioMenuItem_handleButtonClick;
    class MenuPanelChangeEvent extends CustomEvent {
        constructor(detail) {
            super("menuPanelChange", { detail, bubbles: true });
        }
    }
    let XioMenuItem = class XioMenuItem extends Component {
        constructor() {
            super(...arguments);
            _XioMenuItem_hasPanel.set(this, false);
            this.theme = "";
            this.lefty = false;
            this.open = false;
            _XioMenuItem_handleButtonClick.set(this, () => {
                if (__classPrivateFieldGet$b(this, _XioMenuItem_hasPanel, "f")) {
                    this.toggle();
                    this.shadowRoot.querySelector("button").focus();
                }
            });
        }
        toggle(open = !this.open) {
            this.open = open;
            const event = new MenuPanelChangeEvent({ open });
            this.dispatchEvent(event);
            if (this.onMenuPanelChange)
                this.onMenuPanelChange(event);
        }
        updated(changedProperties) {
            const panelSlot = this.shadowRoot.querySelector(`slot[name="panel"]`);
            const panelIsProvided = !!getAssignedElements(panelSlot).length;
            if (__classPrivateFieldGet$b(this, _XioMenuItem_hasPanel, "f") !== panelIsProvided) {
                __classPrivateFieldSet$6(this, _XioMenuItem_hasPanel, panelIsProvided, "f");
                this.requestUpdate();
            }
        }
        render() {
            return $ `
			<button
				part=button
				tabindex=${__classPrivateFieldGet$b(this, _XioMenuItem_hasPanel, "f") ? 0 : -1}
				@click=${__classPrivateFieldGet$b(this, _XioMenuItem_handleButtonClick, "f")}>
					<slot part=buttoncontent></slot>
			</button>
			<slot name=panel part=panel></slot>
		`;
        }
    };
    _XioMenuItem_hasPanel = new WeakMap(), _XioMenuItem_handleButtonClick = new WeakMap();
    __decorate$o([
        e({ type: String, reflect: true })
    ], XioMenuItem.prototype, "theme", void 0);
    __decorate$o([
        e({ type: Boolean, reflect: true })
    ], XioMenuItem.prototype, "lefty", void 0);
    __decorate$o([
        e({ type: Boolean, reflect: true })
    ], XioMenuItem.prototype, "open", void 0);
    XioMenuItem = __decorate$o([
        mixinStyles(xioMenuItemCss)
    ], XioMenuItem);

    var xioMenuCss = r$2 `

.system {
	position: static;
	margin: var(--menu-margin, auto);
}

:host([theme="concrete"]) .system {
	display: flex;
	align-items: flex-end;
	justify-content: flex-end;
}

:host([theme="concrete"][sticky]) .system {
	pointer-events: none;
	position: absolute;
	width: 100%;
	right: 0;
}

:host([theme="concrete"][sticky]) .system > * {
	pointer-events: all;
}

:host([theme="concrete"][lefty]) .system {
	right: auto;
	left: 0;
	align-items: flex-start;
	justify-content: flex-start;
}

:host([theme="concrete"]) [part="blanket"] {
	z-index: 99;
	display: none;
	position: fixed;
	background: var(--menu-blanket-background, rgba(0,0,0, 0.5));
	backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
	--webkit-backdrop-filter: var(--menu-blanket-backdrop-filter, blur(5px));
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
}

:host([theme="concrete"][active]) [part="blanket"] {
	display: block;
}

:host([theme="concrete"]) [part="list"] {
	z-index: 100;
	display: flex;
	align-items: flex-end;
	justify-content: flex-end;
	padding: var(--menu-padding, 0.15rem);
	background: var(--menu-background, rgba(240, 240, 240, 0.5));
	border-radius: var(--menu-border-radius, 0);
}

:host([theme="concrete"][sticky]) [part="list"] {
	margin-right: var(--menu-lanesize, 1rem);
}

:host([theme="concrete"][sticky][lefty]) [part="list"] {
	margin-right: unset;
	margin-left: var(--menu-lanesize, 1rem);
}

:host([theme="concrete"]) [part="list"] slot::slotted(menu-item) {
	display: block;
	flex: 0 0 auto;
}

`;

    var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$a = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$5 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XioMenu_instances, _XioMenu_snap, _XioMenu_untrack, _XioMenu_scrollEvents, _XioMenu_scrollListener, _XioMenu_handleBlanketClick, _XioMenu_enforceOnePanelOpen, _XioMenu_handleMenuPanelChange;
    let XioMenu = class XioMenu extends Component {
        constructor() {
            super(...arguments);
            _XioMenu_instances.add(this);
            this.theme = "concrete";
            this.active = false;
            this.sticky = false;
            this.lefty = false;
            _XioMenu_snap.set(this, snapstate({
                activeIndex: undefined,
                scrollTop: 0,
            }));
            _XioMenu_untrack.set(this, () => { });
            _XioMenu_scrollEvents.set(this, ["scroll", "resize"]);
            _XioMenu_scrollListener.set(this, () => {
                var _a, _b;
                if (!this.active)
                    __classPrivateFieldGet$a(this, _XioMenu_snap, "f").state.scrollTop = this.sticky
                        ? (_b = (_a = window.scrollY) !== null && _a !== void 0 ? _a : window.pageYOffset) !== null && _b !== void 0 ? _b : 0
                        : 0;
            });
            _XioMenu_handleBlanketClick.set(this, () => {
                const items = this.getMenuItems();
                for (const item of items)
                    item.toggle(false);
            });
            _XioMenu_handleMenuPanelChange.set(this, ({ target, detail: { open } }) => {
                const menuItems = this.getMenuItems();
                if (open)
                    __classPrivateFieldGet$a(this, _XioMenu_instances, "m", _XioMenu_enforceOnePanelOpen).call(this, target, menuItems);
                this.active = !!menuItems.find(item => item.open);
                __classPrivateFieldGet$a(this, _XioMenu_scrollListener, "f").call(this);
            });
        }
        createRenderRoot() {
            const shadowRoot = super.createRenderRoot();
            shadowRoot.addEventListener("slotchange", () => this.requestUpdate());
            return shadowRoot;
        }
        connectedCallback() {
            super.connectedCallback();
            __classPrivateFieldSet$5(this, _XioMenu_untrack, __classPrivateFieldGet$a(this, _XioMenu_snap, "f").track(() => this.render(), () => this.requestUpdate()), "f");
            __classPrivateFieldGet$a(this, _XioMenu_scrollListener, "f").call(this);
            for (const event of __classPrivateFieldGet$a(this, _XioMenu_scrollEvents, "f"))
                window.addEventListener(event, __classPrivateFieldGet$a(this, _XioMenu_scrollListener, "f"));
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            __classPrivateFieldGet$a(this, _XioMenu_untrack, "f").call(this);
            __classPrivateFieldSet$5(this, _XioMenu_untrack, () => { }, "f");
            for (const event of __classPrivateFieldGet$a(this, _XioMenu_scrollEvents, "f"))
                window.removeEventListener(event, __classPrivateFieldGet$a(this, _XioMenu_scrollListener, "f"));
        }
        getMenuItems() {
            const slot = this.shadowRoot.querySelector("slot");
            return getAssignedElements(slot)
                .filter(element => element instanceof XioMenuItem);
        }
        updated() {
            for (const item of this.getMenuItems())
                item.theme = this.theme;
        }
        render() {
            const { scrollTop, activeIndex } = __classPrivateFieldGet$a(this, _XioMenu_snap, "f").state;
            return $ `
			<div class=system data-active-index=${activeIndex} style="${`top: ${scrollTop}px`}">
				<div part=blanket @click=${__classPrivateFieldGet$a(this, _XioMenu_handleBlanketClick, "f")}></div>
				<div part=list @menuPanelChange=${__classPrivateFieldGet$a(this, _XioMenu_handleMenuPanelChange, "f")}>
					<slot></slot>
				</div>
			</div>
		`;
        }
    };
    _XioMenu_snap = new WeakMap(), _XioMenu_untrack = new WeakMap(), _XioMenu_scrollEvents = new WeakMap(), _XioMenu_scrollListener = new WeakMap(), _XioMenu_handleBlanketClick = new WeakMap(), _XioMenu_handleMenuPanelChange = new WeakMap(), _XioMenu_instances = new WeakSet(), _XioMenu_enforceOnePanelOpen = function _XioMenu_enforceOnePanelOpen(target, menuItems) {
        const otherMenuItems = menuItems.filter(item => item !== target);
        for (const item of otherMenuItems)
            item.open = false;
    };
    __decorate$n([
        e({ type: String, reflect: true })
    ], XioMenu.prototype, "theme", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioMenu.prototype, "active", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioMenu.prototype, "sticky", void 0);
    __decorate$n([
        e({ type: Boolean, reflect: true })
    ], XioMenu.prototype, "lefty", void 0);
    XioMenu = __decorate$n([
        mixinStyles(xioMenuCss)
    ], XioMenu);

    var styles$k = r$2 `

:host {
	display: inline-block;
	width: var(--avatar-size, 2em);
	height: var(--avatar-size, 2em);
	border-radius: var(--avatar-border-radius, 0.3em);
	overflow: hidden;
	user-select: none;
}

.avatar {
	display: block;
	width: 100%;
	height: 100%;
	color: var(--xio-avatar-color, #444);
	background: var(--xio-avatar-background, #888);
}

.avatar[data-logged-in] {
	color: #fff;
}

svg, img {
	pointer-events: none;
	display: block;
	width: 100%;
	height: 100%;
	object-fit: cover;
}

`;

    var svgSilhouette = y `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill="currentColor" fill-rule="evenodd" d="M12 14.002a.998.998 0 0 1-.998.998H1.001A1 1 0 0 1 0 13.999V13c0-2.633 4-4 4-4s.229-.409 0-1c-.841-.62-.944-1.59-1-4 .173-2.413 1.867-3 3-3s2.827.586 3 3c-.056 2.41-.159 3.38-1 4-.229.59 0 1 0 1s4 1.367 4 4v1.002z"/></svg>`;

    function cap(x, min, max) {
        return x < min
            ? min
            : x > max
                ? max
                : x;
    }
    function hsl(xHue, xSaturation, xLightness) {
        const hue = xHue % 360;
        const saturation = cap(xSaturation, 0, 100);
        const lightness = cap(xLightness, 0, 100);
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    function getNiceColors(value) {
        const base = Math.ceil(value * 360);
        const split_a = (base - 30) % 360;
        const split_b = (base + 30) % 360;
        return {
            color1: hsl(base, 100, 90),
            color2: hsl(split_a, 50, 60),
            color3: hsl(split_b, 50, 40),
        };
    }

    var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioAvatar = class XioAvatar extends Component {
        renderBlankAvatar(spec) {
            return $ `
			<div class=avatar>
				${svgSilhouette}
			</div>
		`;
        }
        renderSimpleAvatar({ value }) {
            const { color1, color2, color3 } = getNiceColors(value);
            const style = `color: ${color1}; background: linear-gradient(to bottom right, ${color2}, ${color3});`;
            return $ `
			<div class=avatar style=${style}>
				${svgSilhouette}
			</div>
		`;
        }
        renderImageAvatar({ link }) {
            return $ `
			<div class=avatar>
				<img src="${link}" alt=""/>
			</div>
		`;
        }
        render() {
            const { spec = { type: "blank" } } = this;
            switch (spec.type) {
                case "blank":
                    return this.renderBlankAvatar(spec);
                case "simple":
                    return this.renderSimpleAvatar(spec);
                case "image":
                    return this.renderImageAvatar(spec);
                default:
                    return $ `avatar missing`;
            }
        }
    };
    __decorate$m([
        e({ type: Object })
    ], XioAvatar.prototype, "spec", void 0);
    XioAvatar = __decorate$m([
        mixinStyles(styles$k)
    ], XioAvatar);

    var styles$j = r$2 `

:host {
	display: inline-block;
	width: max-content;
	height: max-content;
	--_padding: var(--xio-button-padding, 0.2em 0.5em);
	--_background: var(--xio-button-background, transparent);
	--_border: var(--xio-button-border, 1px solid);
	--_border-radius: var(--xio-button-border-radius, 0);
	--_opacity: var(--xio-button-opacity, 0.7);
	--_hover-opacity: var(--xio-button-hover-opacity, 1);
	--_hover-color: var(--xio-button-hover-color, inherit);
	--_hover-background: var(--xio-button-hover-background, var(--_background));
	--_disabled-opacity: var(--xio-button-disabled-opacity, 0.2);
	--_disabled-border-style: var(--xio-button-disabled-border-style, dashed);
}

button {
	width: 100%;
	height: 100%;
	cursor: pointer;
	font: inherit;
	color: inherit;
	padding: var(--_padding);
	font-weight: bold;
	background: var(--_background);
	border: var(--_border);
	border-radius: var(--_border-radius);
	opacity: var(--_opacity);
}

button:not([disabled]):hover,
button:not([disabled]):focus {
	opacity: var(--_hover-opacity);
	color: var(--_hover-color);
	background: var(--_hover-background);
}

button[disabled] {
	cursor: default;
	opacity: var(--_disabled-opacity);
	border-style: var(--_disabled-border-style);
}

`;

    class PressEvent extends CustomEvent {
        constructor(button) {
            super("press", { detail: button });
        }
    }

    var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioButton = class XioButton extends Component {
        constructor() {
            super(...arguments);
            this["disabled"] = false;
            this.handleClick = () => {
                const event = new PressEvent(this);
                if (this.onpress)
                    this.onpress(event);
                if (!this.disabled)
                    this.dispatchEvent(event);
                event.stopPropagation();
            };
        }
        focus() {
            this.shadowRoot.querySelector("button").focus();
        }
        render() {
            return $ `
			<button
				part=button
				@click=${this.handleClick}
				?disabled=${this.disabled}>
					<slot part=button-slot></slot>
			</button>
		`;
        }
    };
    __decorate$l([
        e({ type: Boolean, reflect: true })
    ], XioButton.prototype, "disabled", void 0);
    __decorate$l([
        e({ type: Function })
    ], XioButton.prototype, "onpress", void 0);
    XioButton = __decorate$l([
        mixinFocusable,
        mixinStyles(styles$j)
    ], XioButton);

    var styles$i = r$2 `

.example {
	color: #f90;
}

`;

    var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioExample = class XioExample extends Component {
        render() {
            return $ `
			<div class=example>
				<p>xio-example</p>
				<slot></slot>
			</div>
		`;
        }
    };
    XioExample = __decorate$k([
        mixinStyles(styles$i)
    ], XioExample);

    var styles$h = r$2 `

* {box-sizing: border-box;}

:host {
	display: inline-block;
	vertical-align: middle;
	color: white;
}

:host([disabled]) {
	opacity: 0.25;
}

button {
	display: inline-block;
	border: unset;
	color: unset;
	background: unset;
}

button {
	position: relative;
	width: 1.5em;
	height: 1.5em;
	background: #3338;
	box-shadow: inset 1px 2px 3px #000a;
	border-radius: 0.5em;
	border: 1px solid #fff4;
}

button[data-mode="ready"] {
	cursor: pointer;
}

button[data-mode="ready"]:hover,
button[data-mode="ready"]:focus {
	background: #5558;
	border: 1px solid #fff8;
}

button > span {
	display: inline-block;
}

button svg {
	width: 100%;
	height: 100%;
}

button .error {
	display: inline-block;
	position: absolute;
	top: 80%;
	left: 0;
	width: max-content;
	max-width: 16em;
	color: red;
	background: #200a;
	text-shadow: 1px 2px 3px #0008;
	text-align: left;
	padding: 0.2em 0.5em;
	border-radius: 0.5em;
	pointer-events: none;
}

button[data-mode="loading"] svg,
button[data-mode="error"] svg {
	padding: 10%;
}

button[data-mode="error"] svg {
	color: red;
	animation: fade 1s ease infinite alternate;
}

button[data-mode="loading"] svg {
	animation:
		spin 10s linear infinite,
		fade 500ms ease infinite alternate;
}

@keyframes spin {
	from { transform: rotate(0deg); }
	to { transform: rotate(360deg); }
}

@keyframes fade {
	from { opacity: 1.0; }
	to { opacity: 0.5; }
}

`;

    class CheckEvent extends CustomEvent {
        constructor(checkbox) {
            super("press", { detail: checkbox });
        }
    }

    var checkIcon = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check"><polyline points="20 6 9 17 4 12"></polyline></svg>`;

    var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioCheckbox = class XioCheckbox extends Component {
        constructor() {
            super(...arguments);
            this.loading = ops.none();
            this["initially-checked"] = false;
            this["error-message"] = "error";
            this.disabled = false;
            this.handleClick = () => {
                if (!this.disabled) {
                    this.toggle();
                    const activeElement = document.activeElement;
                    if (activeElement)
                        activeElement.blur();
                }
            };
        }
        init() {
            this.loading = ops.ready(this["initially-checked"]);
        }
        get checked() {
            return ops.value(this.loading);
        }
        set checked(value) {
            this.loading = ops.ready(value);
        }
        async toggle(previousChecked = ops.value(this.loading), dispatchEvent = true) {
            const checked = !previousChecked;
            const isNotDisabled = !this.disabled;
            const isLoadingDone = ops.isReady(this.loading);
            return (isNotDisabled && isLoadingDone)
                ? ops.operation({
                    setOp: op => this.loading = op,
                    errorReason: this["error-message"],
                    promise: (async () => {
                        var _a;
                        await ((_a = this.save) !== null && _a !== void 0 ? _a : (async () => { }))(checked);
                        if (dispatchEvent) {
                            const event = new CheckEvent(this);
                            if (this.oncheck)
                                this.oncheck(event);
                            this.dispatchEvent(event);
                            event.stopPropagation();
                        }
                        return checked;
                    })(),
                })
                : checked;
        }
        render() {
            return $ `
			<button
				data-mode="${ops.mode(this.loading)}"
				?data-checked=${ops.value(this.loading)}
				@click=${this.handleClick}>
					${ops.select(this.loading, {
            none: () => null,
            loading: () => spinnerIcon,
            error: reason => $ `${warningSvg}<div class=error>${reason}</div>`,
            ready: checked => checked
                ? checkIcon
                : null,
        })}
			</button>
		`;
        }
    };
    __decorate$j([
        e()
    ], XioCheckbox.prototype, "loading", void 0);
    __decorate$j([
        e({ type: Boolean })
    ], XioCheckbox.prototype, "initially-checked", void 0);
    __decorate$j([
        e({ type: String })
    ], XioCheckbox.prototype, "error-message", void 0);
    __decorate$j([
        e({ type: Boolean, reflect: true })
    ], XioCheckbox.prototype, "disabled", void 0);
    __decorate$j([
        e({ type: Function })
    ], XioCheckbox.prototype, "oncheck", void 0);
    __decorate$j([
        e({ type: Function })
    ], XioCheckbox.prototype, "save", void 0);
    XioCheckbox = __decorate$j([
        mixinFocusable,
        mixinStyles(styles$h)
    ], XioCheckbox);

    var styles$g = r$2 `

/* * { outline: 1px solid #f002; } */

:host {
	display: block;
	width: 100%;
	max-width: 48rem;
	--height: var(--xio-text-input-height, 5rem);
	--pad: var(--xio-text-input-pad, 0.2em);
	--font: var(--xio-text-input-font, inherit);
	--color: var(--xio-text-input-color, inherit);
	--label-font: var(--xio-text-input-label-font, inherit);
	--label-color: var(--xio-text-input-label-color, inherit);
	--problems-font: var(--xio-text-input-problems-font, inherit);
	--problems-color: var(--xio-text-input-problems-color);
	--background: var(--xio-text-input-background, transparent);
	--valid-color: var(--xio-text-input-valid-color, #00ff8c);
	--invalid-color: var(--xio-text-input-invalid-color, #ff6100);
	--border: var(--xio-text-input-border, 1px solid);
	--border-radius: var(--xio-text-input-border-radius, 0.3em);
}

:host([hidden]) {
	display: none;
}

label {
	font: var(--label-font);
	color: var(--label-color);
}

slot {
	display: block;
	padding: 0 var(--pad);
}

.flexy {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.flexy > * {
	flex: 0 0 auto;
}

:host([textarea]) .flexy {
	flex-direction: column;
}

[part="inputbox"] {
	display: block;
	/* max-width: var(--width); */
	position: relative;
	flex: 1 1 auto;
}

:host([textarea]) [part="inputbox"] {
	flex: 1 1 auto;
	/* max-width: unset; */
}

[part="inputbox"] svg {
	position: absolute;
	display: block;
	top: var(--pad);
	right: var(--pad);
	width: 1.2em;
	height: 1.2em;
	pointer-events: none;
}

.container[data-valid] [part="inputbox"] svg {
	color: var(--valid-color);
}

.container:not([data-valid]) [part="inputbox"] svg {
	color: var(--invalid-color);
}

#textinput {
	min-width: 1em;
	width: 100%;
	font: var(--font);
	padding: var(--pad);
	padding-right: calc(1em + calc(2 * var(--pad)));
	margin: 0;
	color: var(--color);
	background: var(--background);
	border: var(--border);
	border-radius: var(--border-radius);
	text-overflow: ellipsis;
}

textarea {
	min-height: var(--height);
}

[part="problems"] {
	display: flex;
	font: var(--problems-font);
	padding: 0 calc(2 * var(--pad));
	flex-direction: column;
	justify-content: flex-start;
	flex: 1 1 auto;
	/* min-width: 12rem; */
	list-style: none;
	color: var(--problems-color, var(--invalid-color));
}

[part="problems"] > li {
	margin-top: 0.2em;
}

`;

    var svgCircleCheck = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-check-circle"><path d="M22 11.08V12a10 10 0 11-5.93-9.14"/><path d="M22 4L12 14.01l-3-3"/></svg>`;

    function noopParser(text) {
        return text;
    }

    class EnterPressEvent extends CustomEvent {
        constructor() {
            super("enterpress", {
                bubbles: true,
                composed: true,
                detail: undefined,
            });
        }
    }

    class ValueChangeEvent extends CustomEvent {
        constructor(value) {
            super("valuechange", {
                bubbles: true,
                composed: true,
                detail: { value },
            });
        }
    }

    var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XioTextInput = class XioTextInput extends Component {
        constructor() {
            super(...arguments);
            this["initial"] = "";
            this["readonly"] = false;
            this["textarea"] = false;
            this["hide-validation"] = false;
            this["show-validation-when-empty"] = false;
            this["disabled"] = false;
            this["placeholder"] = "";
            this["hidden"] = false;
            this.parser = noopParser;
            this.problems = [];
            this.onvaluechange = () => { };
            this.onenterpress = () => { };
            this.draft = "";
            this.lastDraft = "";
            this.vettedLength = 0;
            this.dispatchValueChange = () => {
                const { draft, lastDraft } = this;
                if (draft !== lastDraft) {
                    this.vettedLength = draft.length;
                    this.dispatchEvent(new ValueChangeEvent(this.value));
                }
                this.lastDraft = draft;
            };
            this.dispatchValueChangeDebounced = debounce(250, this.dispatchValueChange);
            this.dispatchEnterPress = () => {
                this.dispatchEvent(new EnterPressEvent());
            };
            this.updateDraft = () => {
                this.draft = this.input.value;
            };
            this.handleInputKeyPress = (event) => {
                if (event.key === "Enter") {
                    const isTextArea = this.textarea;
                    const isPressingShift = event.shiftKey;
                    const fireEnterPress = () => {
                        this.updateDraft();
                        this.dispatchValueChange();
                        this.dispatchEnterPress();
                        event.preventDefault();
                    };
                    if (isTextArea) {
                        if (isPressingShift)
                            fireEnterPress();
                    }
                    else
                        fireEnterPress();
                }
            };
            this.handleInput = () => {
                this.updateDraft();
                this.dispatchValueChangeDebounced();
            };
            this.handleChange = () => {
                this.updateDraft();
                this.dispatchValueChange();
            };
        }
        get input() {
            return this.shadowRoot
                ? this.shadowRoot.querySelector("#textinput")
                : undefined;
        }
        focus() {
            if (this.input)
                this.input.focus();
        }
        get value() {
            var _a;
            const { draft } = this;
            const parsed = ((_a = this.parser) !== null && _a !== void 0 ? _a : noopParser)(draft);
            this.problems = this.validator ? this.validator(parsed) : [];
            return this.problems.length === 0
                ? parsed
                : undefined;
        }
        get text() {
            return this.draft;
        }
        set text(value) {
            const { input } = this;
            if (input) {
                this.input.value = value;
                this.updateDraft();
                this.dispatchValueChange();
            }
            else {
                this.initial = value;
            }
        }
        init() {
            const { initial } = this;
            this.draft = initial;
            this.lastDraft = initial;
            this.text = initial;
            this.addEventListener("valuechange", this.onvaluechange);
            this.addEventListener("enterpress", this.onenterpress);
            this.dispatchValueChange();
        }
        render() {
            const { readonly, disabled, problems, vettedLength, placeholder, textarea, validator, handleInput, handleInputKeyPress, handleChange, } = this;
            const valid = problems.length === 0;
            const showValidation = !this["hide-validation"] && !readonly && validator && (this["show-validation-when-empty"]
                ? true
                : vettedLength !== 0);
            const showProblems = showValidation && !valid;
            const icon = showValidation
                ? valid
                    ? svgCircleCheck
                    : warningSvg
                : null;
            return $ `
			<div class=container ?data-valid=${valid}>
				<label for=textinput part=label><slot></slot></label>
				<div class=flexy>
					<div part=inputbox>
						${showValidation ? icon : null}
						${textarea ? $ `
							<textarea
								id=textinput
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
							></textarea>
						` : $ `
							<input
								id=textinput
								type=text
								part=textinput
								?disabled=${disabled}
								?readonly=${readonly}
								tabindex=${readonly ? "-1" : "0"}
								placeholder=${placeholder}
								@input=${handleInput}
								@keypress=${handleInputKeyPress}
								@change=${handleChange}
								/>
						`}
					</div>
					<ol part=problems>
						${showProblems
            ? problems.map(problem => $ `
								<li>${problem}</li>
							`)
            : null}
					</ol>
				</div>
			</div>
		`;
        }
    };
    __decorate$i([
        e({ type: String, reflect: true })
    ], XioTextInput.prototype, "initial", void 0);
    __decorate$i([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "readonly", void 0);
    __decorate$i([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "textarea", void 0);
    __decorate$i([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hide-validation", void 0);
    __decorate$i([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "show-validation-when-empty", void 0);
    __decorate$i([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "disabled", void 0);
    __decorate$i([
        e({ type: String, reflect: true })
    ], XioTextInput.prototype, "placeholder", void 0);
    __decorate$i([
        e({ type: Boolean, reflect: true })
    ], XioTextInput.prototype, "hidden", void 0);
    __decorate$i([
        e({ type: Function })
    ], XioTextInput.prototype, "parser", void 0);
    __decorate$i([
        e({ type: Function })
    ], XioTextInput.prototype, "validator", void 0);
    __decorate$i([
        e({ type: Object })
    ], XioTextInput.prototype, "problems", void 0);
    __decorate$i([
        e({ type: String })
    ], XioTextInput.prototype, "text", null);
    __decorate$i([
        e({ type: String })
    ], XioTextInput.prototype, "draft", void 0);
    XioTextInput = __decorate$i([
        mixinFocusable,
        mixinStyles(styles$g)
    ], XioTextInput);

    class NightlightChangeEvent extends CustomEvent {
        constructor(detail) {
            super("nightlightChange", {
                detail,
                bubbles: true,
            });
        }
    }

    const nightlightStorageKey = "nightlightSettings";
    function nightlightSettingStorage() {
        return {
            save(settings) {
                if (settings)
                    window.localStorage.setItem(nightlightStorageKey, JSON.stringify(settings));
                else
                    window.localStorage.removeItem(nightlightStorageKey);
            },
            load() {
                const data = window.localStorage.getItem(nightlightStorageKey);
                return data
                    ? JSON.parse(data)
                    : undefined;
            },
        };
    }

    var xioThemerCss = r$2 `

:host {
	display: inline-block;
	width: 2em;
	height: 2em;
}

button {
	display: block;
	font-size: inherit;
	color: inherit;
	background: transparent;
	border: none;
	width: 100%;
	height: 100%;

	Xtransform: scale(1);
	Xtransition: transform 200ms ease;
}

Xbutton:active {
	transform: scale(0.8);
}

slot {
	display: block;
	width: 100%;
	height: 100%;
}

slot svg, slot::slotted(svg) {
	display: block;
	width: 100%;
	height: 100%;
}

`;

    var sunSvg = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`;

    var moonSvg = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`;

    var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$9 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioNightlight_instances, _XioNightlight_storage, _XioNightlight_setNightOnSourceElement, _XioNightlight_dispatchChange;
    const nightlightDataAttributeName = "data-nightlight";
    /*

    nightlight is a toggle button for dark theme.

    in "night" mode, the "data-nightlight" attribute is set on the source element.

        <body data-nightlight>

    if you want to start your website in night mode by default,
    just start your source element with the "data-nightlight" attribute.

    */
    let XioNightlight = class XioNightlight extends Component {
        constructor() {
            super(...arguments);
            _XioNightlight_instances.add(this);
            this["show-destination-state"] = false;
            this["title-to-night"] = "turn down the lights";
            this["title-to-day"] = "turn up the lights";
            this.sourceElement = document.documentElement;
            _XioNightlight_storage.set(this, nightlightSettingStorage());
        }
        firstUpdated() {
            const settings = __classPrivateFieldGet$9(this, _XioNightlight_storage, "f").load();
            if (settings)
                this.night = settings.night;
            window.addEventListener("nightlightChange", event => {
                if (event.target !== this)
                    this.requestUpdate();
            });
        }
        get night() {
            return this.sourceElement.getAttribute(nightlightDataAttributeName) !== null;
        }
        set night(value) {
            __classPrivateFieldGet$9(this, _XioNightlight_storage, "f").save({ night: value });
            const previous = this.night;
            if (value !== previous) {
                __classPrivateFieldGet$9(this, _XioNightlight_instances, "m", _XioNightlight_setNightOnSourceElement).call(this, value);
                this.requestUpdate();
                __classPrivateFieldGet$9(this, _XioNightlight_instances, "m", _XioNightlight_dispatchChange).call(this);
            }
        }
        toggle(night = !this.night) {
            this.night = night;
        }
        render() {
            const { night } = this;
            const showNight = this["show-destination-state"]
                ? !night
                : night;
            return $ `
			<button
				part=button
				title="${night ? this["title-to-day"] : this["title-to-night"]}"
				?data-nightlight=${night}
				@click=${() => this.toggle()}>
					${showNight
            ? $ `
							<slot name=night>
								${moonSvg}
							</slot>
						`
            : $ `
							<slot name=day>
								${sunSvg}
							</slot>
						`}
			</button>
		`;
        }
    };
    _XioNightlight_storage = new WeakMap(), _XioNightlight_instances = new WeakSet(), _XioNightlight_setNightOnSourceElement = function _XioNightlight_setNightOnSourceElement(night) {
        if (night)
            this.sourceElement.setAttribute(nightlightDataAttributeName, "");
        else
            this.sourceElement.removeAttribute(nightlightDataAttributeName);
    }, _XioNightlight_dispatchChange = function _XioNightlight_dispatchChange() {
        const event = new NightlightChangeEvent({ night: this.night });
        this.dispatchEvent(event);
        if (this.onNightlightChange)
            this.onNightlightChange(event);
    };
    XioNightlight.NightlightChangeEvent = NightlightChangeEvent;
    __decorate$h([
        e({ type: Boolean, reflect: true })
    ], XioNightlight.prototype, "show-destination-state", void 0);
    __decorate$h([
        e({ type: String, reflect: true })
    ], XioNightlight.prototype, "title-to-night", void 0);
    __decorate$h([
        e({ type: String, reflect: true })
    ], XioNightlight.prototype, "title-to-day", void 0);
    XioNightlight = __decorate$h([
        mixinStyles(xioThemerCss)
    ], XioNightlight);

    var styles$f = r$2 `

:host {
	display: inline-block;
	--local-avatar-size: var(--avatar-size, 3em);
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

xio-avatar {
	flex: 0 0 auto;
	margin-right: 0.4em;
	--avatar-size: var(--local-avatar-size);
}

.box {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	flex: 1;
	flex-basis: 8em;
}

[part="nameplate"] {
	flex: 1 1 auto;
	margin-right: 1em;
	margin-bottom: 0.5em;
}

[part="details"] {
	margin-bottom: 0.5em;
}

.buttonbar {
	margin-top: 0.5em;
}

.cardplate > * {
	display: block;
}

.tags {
	list-style: none;
	font-size: 0.6em;
	cursor: default;
}

.tags > li {
	display: inline-block;
	margin: 0 0.1em;
	padding: 0 0.25em;
	border: 1px solid;
	border-radius: 1em;
}

[data-tag=staff] {
	color: var(--cobalt-tagcolor-staff, lime);
}

[data-tag=banned] {
	color: var(--cobalt-tagcolor-banned, red);
}

p[data-field=tagline] {
	opacity: 0.7;
	font-size: 0.7em;
	font-style: italic;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7rem;
}

xio-text-input + xio-text-input {
	margin-top: 0.1em;
}

[part="details"] {
	font-size: 0.7em;
	list-style: none;
}

[part="details"] > li {
	margin-top: 0.2em;
}

[part="details"] > li > :first-child {
	font-weight: bold;
}

[part="details"] code {
	font-size: 0.6em;
	padding: 0.2em;
	border-radius: 0.3em;
	word-break: break-all;
	background: #0002;
}

.roles {
	font-size: 0.6em;
	list-style: none;
	padding: 0;
	margin-top: 0.3rem;
}

.roles li {
	display: inline-block;
	border: 1px solid;
	border-radius: 1em;
	padding: 0.1em 0.3em;
	line-height: 0.8em;
}

`;

    const isSet = (a) => (a !== null && a !== undefined);
    function deepEqual(a, b) {
        if (!isSet(a) || !isSet(b))
            return a === b;
        for (const [key, aValue] of Object.entries(a)) {
            if (!b.hasOwnProperty(key))
                return false;
            const bValue = b[key];
            switch (typeof aValue) {
                case "object":
                    if (!deepEqual(aValue, bValue))
                        return false;
                    break;
                case "function":
                    if (!isSet(bValue) || aValue.toString() !== bValue.toString())
                        return false;
                    break;
                default:
                    if (aValue !== bValue)
                        return false;
            }
        }
        for (const [key] of Object.entries(a))
            if (!b.hasOwnProperty(key))
                return false;
        for (const [key] of Object.entries(b))
            if (!a.hasOwnProperty(key))
                return false;
        return true;
    }

    function renderText({ field, initial, text, input }) {
        return input
            ? $ `
			<xio-text-input
				data-field="${field}"
				initial="${initial}"
				text="${text}"
				part="xiotextinput"
				exportparts="${`
					label: xiotextinput-label,
					textinput: xiotextinput-textinput,
					problems: xiotextinput-problems,
				`}"
				show-validation-when-empty
				?readonly=${input.readonly}
				?hide-validation=${!input.draftIsChanged}
				.validator=${input.validator}
				@valuechange=${input.onvaluechange}>
					<span>${input.label}</span>
			</xio-text-input>
		`
            : $ `
			<p part="textfield" data-field="${field}">${initial}</p>
		`;
    }

    function renderRoles(user) {
        return $ `
		<ul class=roles>
			${user.roles.map(role => $ `
				<li
					data-role-label="${role.label}"
					data-role-id="${role.roleId}">
						${role.label}
				</li>
			`)}
		</ul>
	`;
    }

    function select(selector, context = document) {
        return context.querySelector(selector);
    }

    function formatDate(milliseconds) {
        const d = new Date(milliseconds);
        const twoDigit = (n) => n.toString().padStart(2, "0");
        const year = twoDigit(d.getFullYear());
        const month = twoDigit(d.getMonth() + 1);
        const day = twoDigit(d.getDate());
        const hours24 = d.getHours();
        let hours = d.getHours();
        hours %= 12;
        hours = hours ? hours : 12;
        const minutes = twoDigit(d.getMinutes());
        const ampm = hours24 >= 12 ? "pm" : "am";
        const timezoneOffsetMinutes = -d.getTimezoneOffset();
        const timezoneOffset = (timezoneOffsetMinutes / 60).toFixed(timezoneOffsetMinutes % 60 === 0
            ? 0
            : 1);
        const timezoneUtc = timezoneOffsetMinutes === 0
            ? "UTC"
            : `UTC${timezoneOffsetMinutes < 0 ? "" : "+"}${timezoneOffset}`;
        const timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const timezone = `${timezoneName} ${timezoneUtc}`;
        const date = `${year}-${month}-${day}`;
        const time = `${hours}:${minutes} ${ampm}`;
        const zone = `${timezone}`;
        const full = `${date} ${time} (${zone})`;
        return {
            date,
            time,
            zone,
            full,
        };
    }

    function renderDetails(user) {
        return $ `
		<ul part=details>
			<li>
				<span>joined:</span>
				<span>${formatDate(user.stats.joined).date}</span>
			</li>
			<li>
				<span>user id:</span>
				<span><xio-id id="${user.userId}"></xio-id></span>
			</li>
		</ul>
	`;
    }

    function makeProfileDraft(profile) {
        return {
            tagline: profile.tagline,
            nickname: profile.nickname,
        };
    }

    function whenOpReady(op, render) {
        return ops.isReady(op)
            ? render(ops.value(op))
            : null;
    }

    function renderOp(op, render, more = null, { loadingMessage, errorMessage, showErrorText } = {}) {
        return $ `
		<xio-op
			.op=${op}
			loading-message="${loadingMessage}"
			error-message="${errorMessage}"
			show-error-text="${showErrorText}">
				${whenOpReady(op, render)}
				${more}
		</xio-op>
	`;
    }

    function validator(...conditions) {
        return value => {
            let problems = [];
            for (const condition of conditions) {
                problems = condition(value);
                if (problems.length > 0)
                    break;
            }
            return problems;
        };
    }
    function branch(...conditions) {
        return value => {
            const results = conditions.map(condition => condition(value));
            let anySuccess = false;
            for (const problems of results)
                if (problems.length === 0)
                    anySuccess = true;
            return anySuccess
                ? []
                : results.flat()
                    .map((problem, index) => index > 0 ? `or, ${problem}` : problem);
        };
    }
    function each(...conditions) {
        return arr => {
            if (!Array.isArray(arr))
                return ["must be array"];
            const validate = validator(...conditions);
            const problems = [];
            arr.forEach((item, index) => {
                for (const problem of validate(item))
                    problems.push(`(${index + 1}) ${problem}`);
            });
            return problems;
        };
    }
    const string = () => value => typeof value !== "string"
        ? ["must be a string"]
        : [];
    const array = () => value => Array.isArray(value)
        ? []
        : ["must be an array"];
    const minLength = (min) => value => value.length < min
        ? ["too small"]
        : [];
    const maxLength = (max) => value => value.length > max
        ? ["too big"]
        : [];
    const notWhitespace = () => value => value.length > 0 && value.trim().length === 0
        ? ["can't be all whitespace"]
        : [];
    const zeroWhitespace = () => value => /\s/.test(value)
        ? ["must not have any spaces"]
        : [];
    const url = () => value => {
        try {
            void new URL(value);
            return [];
        }
        catch (error) {
            return ["invalid url"];
        }
    };
    const localhost = () => value => {
        return /^https?:\/\/(127\.0\.0\.1|localhost)(|:\d{1,5})(|\/\S*)$/i.test(value)
            ? []
            : ["must be a localhost address"];
    };
    const https = () => value => {
        return /^https:\/\//i.test(value)
            ? []
            : ["must be secure, starting with 'https'"];
    };
    const origin = () => value => /^https?:\/\/[a-zA-Z\.\d-]+(?:|:\d+)$/i.test(value)
        ? []
        : ["invalid origin"];
    const emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    const email = () => value => emailRegex.test(value)
        ? []
        : ["invalid email"];
    // const labelValidator = validator<string>(string(), minLength(1), maxLength(50), notWhitespace())
    // const problems = labelValidator("hello")
    // const problems2 = validator<string[]>(array(string()))

    const profileValidators = {
        nickname: validator(string(), minLength(1), maxLength(24), notWhitespace()),
        tagline: validator(string(), minLength(0), maxLength(32), notWhitespace()),
    };

    var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$8 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XioProfileCard_state;
    let XioProfileCard = class XioProfileCard extends Component {
        constructor() {
            super(...arguments);
            _XioProfileCard_state.set(this, snapstate({
                busy: ops.ready(undefined),
            }));
            this.profileDraft = undefined;
            this.problems = [];
            this.handleChange = debounce(200, () => {
                if (!this.user)
                    return;
                const { profileDraft, isChanged } = this.generateNewProfileDraftFromInputs();
                this.profileDraft = isChanged ? profileDraft : undefined;
            });
            this.handleSave = async () => {
                const { profileDraft } = this;
                await ops.operation({
                    promise: this.saveProfile(profileDraft)
                        .finally(() => {
                        this.profileDraft = null;
                    }),
                    setOp: op => __classPrivateFieldGet$8(this, _XioProfileCard_state, "f").writable.busy = op,
                });
                this.requestUpdate();
                await this.updateComplete;
                const setToTextField = (field, text) => {
                    const input = this.shadowRoot.querySelector(`xio-text-input[data-field="${field}"]`);
                    input.text = text;
                };
                setToTextField("nickname", profileDraft.nickname);
                setToTextField("tagline", profileDraft.tagline);
            };
        }
        init() {
            this.addSubscription(() => __classPrivateFieldGet$8(this, _XioProfileCard_state, "f").subscribe(() => this.requestUpdate()));
        }
        get draftIsChanged() {
            return !!this.profileDraft;
        }
        get readonly() {
            return !this.saveProfile;
        }
        getTextInputField(name) {
            return select(`xio-text-input[data-field="${name}"]`, this.shadowRoot);
        }
        generateNewProfileDraftFromInputs() {
            const { profile } = this.user;
            const profileDraft = makeProfileDraft(profile);
            const nicknameInput = this.getTextInputField("nickname");
            if (!nicknameInput)
                return { profileDraft, isChanged: false };
            const taglineInput = this.getTextInputField("tagline");
            profileDraft.nickname = nicknameInput.value;
            profileDraft.tagline = taglineInput.value;
            this.problems = [...nicknameInput.problems, ...taglineInput.problems];
            const isChanged = !deepEqual(makeProfileDraft(profile), profileDraft);
            return { profileDraft, isChanged };
        }
        render() {
            const { user, draftIsChanged } = this;
            if (!user)
                return null;
            const avatarSpec = user.profile.avatar;
            return renderOp(__classPrivateFieldGet$8(this, _XioProfileCard_state, "f").readable.busy, () => $ `
			<div class=container ?data-readonly=${this.readonly}>
				<xio-avatar part=avatar .spec=${avatarSpec}></xio-avatar>
				<div class=box>
					<div part=nameplate>
						${renderText({
            field: "nickname",
            initial: this.profileDraft
                ? this.profileDraft.nickname
                : user.profile.nickname,
            text: user.profile.nickname,
            input: this.readonly
                ? undefined
                : {
                    label: "nickname",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.nickname,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderText({
            field: "tagline",
            initial: this.profileDraft
                ? this.profileDraft.tagline
                : user.profile.tagline,
            text: user.profile.tagline,
            input: this.readonly
                ? undefined
                : {
                    label: "tagline",
                    readonly: false,
                    draftIsChanged,
                    validator: profileValidators.tagline,
                    onvaluechange: this.handleChange,
                }
        })}
						${renderRoles(user)}
						${this.readonly ? null : $ `
							<div class=buttonbar>
								<xio-button
									?disabled=${!this.profileDraft || this.problems.length > 0}
									@press=${this.handleSave}>
										<slot name=save-button>save profile</slot>
								</xio-button>
							</div>
						`}
					</div>
					${this["show-details"]
            ? renderDetails(user)
            : null}
				</div>
			</div>
		`);
        }
    };
    _XioProfileCard_state = new WeakMap();
    __decorate$g([
        e({ type: Boolean })
    ], XioProfileCard.prototype, "show-details", void 0);
    __decorate$g([
        e({ type: Object })
    ], XioProfileCard.prototype, "user", void 0);
    __decorate$g([
        e({ type: Object })
    ], XioProfileCard.prototype, "saveProfile", void 0);
    __decorate$g([
        e({ type: Object })
    ], XioProfileCard.prototype, "profileDraft", void 0);
    XioProfileCard = __decorate$g([
        mixinStyles(styles$f)
    ], XioProfileCard);

    function integrateXioComponents() {
        return {
            XioId,
            XioOp,
            XioMenu,
            XioAvatar,
            XioButton,
            XioExample,
            XioCheckbox,
            XioMenuItem,
            XioTextInput,
            XioNightlight,
            XioProfileCard,
        };
    }

    var adminManagerCss = r$2 `

.adminmanager .adminassigner {
	display: flex;
	flex-direction: row;
	margin: 0.5em 0;
}

.adminmanager .adminassigner > * {
	display: block;
}

.adminmanager .adminassigner > xio-text-input {
	flex: 1 1 auto;
}

.adminmanager .adminassigner > xio-text-input {
	width: 100%;
	max-width: 100%;
}

.adminmanager .adminassigner > xio-text-input::part(problems) {
	min-width: unset;
}

.adminmanager .adminassigner > xio-button {
	margin-top: 1.1em;
	margin-left: 0.3em;
}

.adminmanager .adminlist ul {
	list-style: none;
	padding: 0 1em;
	border: 1px solid #fff1;
}

.adminmanager .adminlist li {
	display: flex;
	flex-direction: row;
	align-content: center;
	padding: 0.3em 0;
	font-size: 0.8em;
}

.adminmanager .adminlist li + li {
	border-top: 1px solid #fff1;
}

.adminmanager .adminlist li > * {
	display: block;
}

.adminmanager .adminlist li > span {
	flex: 1 1 auto;
	display: flex;
	align-items: center;
	word-break: break-all;
}

.adminmanager .adminlist li > xio-button {
	color: #fff3;
}

`;

    var styles$e = r$2 `

:host {
	display: block;
}

.app-list {
	margin-top: 2em;
	margin-bottom: 2em;
}

.app-list > xio-op {
	display: block;
	border: 1px solid #f00;
	margin-top: 0.5em;
	border: 1px solid #fff1;
	border-radius: 0.2em;
}

.app-list > xio-op[mode="loading"] {
	padding: 4em 2em;
}

.app > * + * {
	margin-top: 0.3em;
}

.app + .app {
	margin-top: 1.5em;
}

.app > * {
	padding: 0.4em 1rem;
}

.app-header {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	justify-content: flex-end;
	padding: 0;
	background: #0001;
}

.app-header .title {
	max-width: 100%;
	flex: 1 0 auto;
	padding: 0.3em 1em;
}

.app-header .title h3 {
	font-size: 1.5em;
	font-weight: bold;
}

.app-header .title h3::before {
	content: "🌐";
	color: white;
}

.app-header .stats {
	display: flex;
	flex-direction: row;
	justify-content: center;
	flex-wrap: wrap;
	padding: 0.2em;
}

.app-header .stats [data-stat] {
	display: flex;
	flex-direction: column;
	justify-content: flex-end;
	max-width: 6em;
	text-align: center;
}

.app-header .stats [data-stat] > span {
	padding: 0.1em 0.6em;
}

.app-header .stats [data-stat] > span:nth-child(1) {
	justify-self: flex-start;
}

.app-header .stats [data-stat] > span:nth-child(2) {
	opacity: 0.3;
	font-size: 0.6em;
}

.twoside {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
}

.twoside > div {
	max-width: 100%;
	flex: 1 0 16em;
	padding-bottom: 1em;
}

.twoside > div:nth-child(1) {
	padding-right: 1rem;
}

.editside > .buttons {
	display: flex;
	justify-content: center;
	align-items: center;
}

.app-form > * + * {
	margin-top: 0.3em;
}

.app-form xio-button {
	margin-top: 0.6em;
}

.app-options {
	border: 1px solid #fff1;
	padding: 1em;
}

.app-options > * + * {
	margin-top: 3em;
}

code {
	display: inline-block;
	font-size: 0.8em;
	padding: 0.2em;
	border-radius: 0.3em;
	background: #0002;
	overflow-wrap: anywhere;
	word-break: break-all;
}

code.id {
	opacity: 0.7;
	font-size: 0.5em;
}

.codeblock {
	display: block;
}

.htmlcode { color: #fff6; }
.htmlcode [data-syntax=tag] { color: deepskyblue; }
.htmlcode [data-syntax=attr] { color: skyblue; }
.htmlcode [data-syntax=data] { color: #aaffa0; }
.htmlcode [data-syntax=indent] {
	display: block;
	margin-left: 1em;
}

.app-code > * {
	margin-top: 1em;
}

.app-code code {
	display: block;
	font-size: 0.6em;
	padding: 1em;
	margin: 0.5em 0;
}

.delete-app-button {
	display: block;
	text-align: right;
	--xio-button-hover-color: red;
}

${adminManagerCss}

.app-list {
	margin-bottom: 5rem;
}

.app-registration {
	max-width: 40em;
	margin-bottom: 5em;
}

`;

    function renderXiomeConfig(appId) {
        const h = (syntax, s) => $ `<span data-syntax=${syntax}>${s}</span>`;
        const tag = (s) => h("tag", s);
        const attr = (s) => h("attr", s);
        const data = (s) => h("data", s);
        const glue = (s) => h("glue", s);
        const quote = glue(`"`);
        const bundle_link = "https://xiome.io/xiome.bundle.min.js";
        return $ `
		${glue(`<`)}${tag(`script`)} ${attr(`async`)} ${attr(`defer`)} ${attr(`src`)}${glue(`=`)}${quote}${data(bundle_link)}${quote}${glue(`>`)}${glue(`</`)}${tag(`script`)}${glue(`>`)}
		<br/>
		${glue(`<`)}${tag(`xiome-config`)} ${attr(`app`)}${glue(`=`)}${quote}${data(appId)}${quote}${glue(`>`)}${glue(`</`)}${tag(`xiome-config`)}${glue(`>`)}
	`;
    }

    const parseOrigins = (text) => text
        .split("\n")
        .map(line => line.trim().toLowerCase())
        .filter(line => line.length > 0);

    const validateAppOrigin = validator(string(), maxLength(1000), origin(), branch(https(), localhost()));
    const appDraftValidators = Object.freeze({
        home: validator(string(), minLength(1), maxLength(2000), branch(validator(url(), https()), localhost())),
        label: validator(string(), minLength(1), maxLength(50), notWhitespace()),
        origins: validator(minLength(1), maxLength(100), each(validateAppOrigin)),
        additionalOrigins: validator(array(), minLength(0), maxLength(99), each(validateAppOrigin)),
    });

    function validateAppFormDraft(formDraft) {
        const problems = [
            ...appDraftValidators.label(formDraft.label),
            ...appDraftValidators.home(formDraft.home),
            ...appDraftValidators.additionalOrigins(formDraft.additionalOrigins),
        ];
        return problems;
    }

    function getEmptyAppFormDraft() {
        return {
            home: "",
            label: "",
            additionalOrigins: [],
        };
    }

    function makeAppForm({ clearOnSubmit, submitButtonText, showAdditionalOrigins, initialValues = getEmptyAppFormDraft(), query, submit, requestUpdate, }) {
        const state = {
            problems: [],
            formDisabled: false,
            draft: initialValues,
            get valid() {
                return !this.formDisabled
                    && this.draft
                    && this.problems.length === 0;
            },
        };
        function getFormElements() {
            return {
                home: query(`.app-form [data-form="home"]`),
                label: query(`.app-form [data-form="label"]`),
                additionalOrigins: query(`.app-form [data-form="additional-origins"]`),
            };
        }
        function setFormValues(draft) {
            const elements = getFormElements();
            elements.home.text = draft.home;
            elements.label.text = draft.label;
            elements.additionalOrigins.text = draft.additionalOrigins.join("\n");
        }
        const refreshAndValidateForm = () => {
            const { home, label, additionalOrigins } = getFormElements();
            state.draft = {
                home: home.value,
                label: label.value,
                additionalOrigins: additionalOrigins.value,
            };
            state.problems = validateAppFormDraft(state.draft);
            requestUpdate();
        };
        function handleFormChange() {
            state.problems = [];
            if (!state.formDisabled)
                refreshAndValidateForm();
        }
        async function handleSubmitClick() {
            refreshAndValidateForm();
            state.formDisabled = true;
            requestUpdate();
            try {
                await submit(state.draft);
                if (clearOnSubmit) {
                    initialValues = getEmptyAppFormDraft();
                    setFormValues(initialValues);
                }
                else {
                    initialValues = state.draft;
                }
            }
            finally {
                state.formDisabled = false;
                requestUpdate();
            }
        }
        function render({ partNamespace }) {
            const { formDisabled, draft, problems } = state;
            const changes = !deepEqual(initialValues, draft);
            const submitButtonDisabled = !changes
                || formDisabled
                || problems.length > 0;
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: ${partNamespace}-appform-xiotextinput-label,
			textinput: ${partNamespace}-appform-xiotextinput-textinput,
			problems: ${partNamespace}-appform-xiotextinput-problems,
		`;
            const renderTextInput = ({ hide, textarea, label, dataForm, initialText, showValidationWhenEmpty, parser, validator, }) => $ `
			<xio-text-input
				?textarea=${textarea}
				part="${partNamespace}-appform-xiotextinput"
				exportparts="${exportPartsTextInput}"
				data-form="${dataForm}"
				initial="${initialText}"
				?hidden=${hide}
				?disabled=${formDisabled}
				?hide-validation=${!changes}
				?show-validation-when-empty=${showValidationWhenEmpty}
				.parser=${parser}
				.validator=${validator}
				@valuechange=${handleFormChange}>
					<span part=xio-text-input-label>
						${label}
					</span>
			</xio-text-input>
		`;
            return $ `
			<div class=app-form>
				<slot name=create-app-heading></slot>

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "label",
            label: "community name",
            initialText: initialValues.label,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.label,
        })}

				${renderTextInput({
            hide: false,
            textarea: false,
            dataForm: "home",
            label: `website homepage, like "https://chasemoskal.com/"`,
            initialText: initialValues.home,
            showValidationWhenEmpty: false,
            parser: undefined,
            validator: appDraftValidators.home,
        })}

				${renderTextInput({
            hide: !showAdditionalOrigins,
            textarea: true,
            dataForm: "additional-origins",
            label: "(optional) additional domain names",
            initialText: initialValues.additionalOrigins.join("\n"),
            showValidationWhenEmpty: true,
            parser: parseOrigins,
            validator: appDraftValidators.additionalOrigins,
        })}

				<xio-button
					class="create-app-button"
					?disabled=${submitButtonDisabled}
					@press=${handleSubmitClick}>
						${submitButtonText}
				</xio-button>
			</div>
		`;
        }
        return { render };
    }

    const emailValidator = validator(string(), maxLength(256), email());

    function adminManagerControls({ app, state, actions, appEditService, }) {
        const { appId } = app;
        const load = (firstStep = Promise.resolve(undefined)) => (ops.operation({
            promise: firstStep
                .then(() => appEditService.listAdmins({ appId })),
            setOp: admins => actions.setAdmins(admins)
        }));
        async function listAdmins() {
            await load();
        }
        async function assignAdmin() {
            const { email } = state.assignerDraft;
            actions.setAssignerDraft({ email: undefined });
            await load(appEditService.assignAdmin({ appId, email }));
        }
        async function revokeAdmin(userId) {
            await load(appEditService.revokeAdmin({ appId, userId }));
        }
        return { listAdmins, assignAdmin, revokeAdmin };
    }

    function adminManagerStateAndActions() {
        const state = snapstate({
            admins: ops.none(),
            assignerDraft: {
                email: undefined,
            },
        });
        const actions = {
            setAdmins(op) {
                state.writable.admins = op;
            },
            setAssignerDraft(draft) {
                state.writable.assignerDraft = draft;
            },
        };
        return {
            subscribe: state.subscribe,
            state: state.readable,
            actions,
        };
    }

    function makeAdminManager({ app, appEditService, query }) {
        const { state, actions, subscribe } = adminManagerStateAndActions();
        const controls = adminManagerControls({
            app,
            state,
            actions,
            appEditService,
        });
        function handleEmailChange(event) {
            var _a;
            const email = (_a = event.detail.value) !== null && _a !== void 0 ? _a : undefined;
            actions.setAssignerDraft({ email });
        }
        function handleAssignButtonPress() {
            const textInput = query(".adminassigner xio-text-input");
            controls.assignAdmin();
            textInput.text = "";
        }
        function renderAdminAssigner() {
            const exportPartsTextInput = `
			label: xiotextinput-label,
			textinput: xiotextinput-textinput,
			problems: xiotextinput-problems,

			label: adminmanager-xiotextinput-label,
			textinput: adminmanager-xiotextinput-textinput,
			problems: adminmanager-xiotextinput-problems,
		`;
            return $ `
			<div class=adminassigner>
				<xio-text-input
					part=adminmanager-xiotextinput
					exportparts="${exportPartsTextInput}"
					.validator=${emailValidator}
					@valuechange=${handleEmailChange}>
						email
				</xio-text-input>
				<xio-button
					?disabled=${!state.assignerDraft.email}
					@press=${handleAssignButtonPress}>
						grant
				</xio-button>
			</div>
		`;
        }
        function renderAdminList() {
            return $ `
			<div class=adminlist>
				${renderOp(state.admins, admins => $ `
					<ul>
						${admins.map(({ email, userId }) => $ `
							<li>
								<span>${email}</span>
								<xio-button @press=${() => controls.revokeAdmin(userId)}>
									revoke
								</xio-button>
							</li>
						`)}
					</ul>
				`)}
			</div>
		`;
        }
        function render() {
            return $ `
			${renderAdminAssigner()}
			${renderAdminList()}
		`;
        }
        return { render, controls, subscribe };
    }

    function dedupe(arr) {
        return [...new Set(arr)];
    }

    function formDraftToAppDraft(formDraft) {
        return {
            home: formDraft.home,
            label: formDraft.label,
            origins: dedupe([
                new URL(formDraft.home).origin,
                ...formDraft.additionalOrigins,
            ])
        };
    }

    // TODO obsolete
    // usage of these functions should be replaced by the better assertive-map.ts
    function strongRecordKeeper() {
        return function (makeRecord) {
            const map = new Map();
            return function getRecord(key) {
                let record;
                if (map.has(key))
                    record = map.get(key);
                else {
                    record = makeRecord(key);
                    map.set(key, record);
                }
                return record;
            };
        };
    }

    function originsMinusHome(home, origins) {
        return origins
            .filter(o => o.toLowerCase() !== new URL(home.toLowerCase()).origin)
            .map(o => o.toLowerCase());
    }

    function appDisplayToFormDraft(display) {
        return {
            home: display.home,
            label: display.label,
            additionalOrigins: originsMinusHome(display.home, display.origins),
        };
    }

    var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeAppManager = class XiomeAppManager extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.appRegistrationForm = makeAppForm({
                clearOnSubmit: true,
                showAdditionalOrigins: false,
                submitButtonText: "create community",
                requestUpdate: () => this.requestUpdate(),
                query: selector => (this.shadowRoot
                    .querySelector(".app-registration")
                    .querySelector(selector)),
                submit: async (formDraft) => {
                    const appDraft = formDraftToAppDraft(formDraft);
                    await this.share.appsModel.registerApp(appDraft);
                },
            });
            this.getAppState = strongRecordKeeper()(appId => {
                const app = this.share.appsModel.getApp(appId);
                const state = snapstate({
                    editMode: false,
                });
                const actions = {
                    toggleEditMode() {
                        state.writable.editMode = !state.writable.editMode;
                    },
                };
                state.subscribe(() => this.requestUpdate());
                return {
                    toggleEditMode: actions.toggleEditMode,
                    get editMode() { return state.readable.editMode; },
                    appForm: makeAppForm({
                        clearOnSubmit: false,
                        showAdditionalOrigins: true,
                        submitButtonText: "save changes",
                        initialValues: appDisplayToFormDraft(app),
                        requestUpdate: () => { this.requestUpdate(); },
                        query: selector => (this.shadowRoot
                            .querySelector(`.app[data-app-id="${app.appId}"] .app-options`)
                            .querySelector(selector)),
                        submit: async (formDraft) => {
                            const appDraft = formDraftToAppDraft(formDraft);
                            await this.share.appsModel.updateApp(app.appId, appDraft);
                        },
                    }),
                    adminManager: (() => {
                        const manager = makeAdminManager({
                            app,
                            appEditService: this.share.appsModel.appEditService,
                            query: selector => this.shadowRoot
                                .querySelector(`.app[data-app-id="${app.appId}"] .adminmanager`)
                                .querySelector(selector)
                        });
                        manager.subscribe(() => this.requestUpdate());
                        manager.controls.listAdmins();
                        return manager;
                    })(),
                };
            });
            this.deleteApp = async (app) => {
                const userIsSure = await this.share.modals.confirm({
                    title: "are you certain?",
                    body: `you really want to delete your community "${app.label}"?`,
                    yes: { label: "delete whole community", vibe: "negative" },
                    no: { label: "nevermind", vibe: "neutral" },
                    focusNthElement: 2,
                });
                if (userIsSure)
                    await this.share.appsModel.deleteApp(app.appId);
            };
        }
        init() {
            this.share.appsModel.loadApps();
        }
        renderAppRegistration() {
            return $ `
			<div class=app-registration>
				<slot name="register-app-heading"></slot>
				${this.appRegistrationForm.render({ partNamespace: "appregistration" })}
			</div>
		`;
        }
        renderNoApps() {
            return $ `
			<slot name=no-apps></slot>
			${this.renderAppRegistration()}
		`;
        }
        renderAppList(records) {
            return $ `
			<slot></slot>
			<div class=app-list>
				${Object.entries(records)
            .map(([appId, record]) => renderOp(record, app => this.renderApp(app)))}
			</div>
			${this.renderAppRegistration()}
		`;
        }
        renderAppBankLinking(app) {
            return null;
            // return html`
            // 	<div>
            // 		<h4>bank link to receive payouts</h4>
            // 		<xiome-bank-connect .appId=${app.appId}></xiome-bank-connect>
            // 	</div>
            // `
        }
        renderAppCode(appId) {
            return $ `
			<div class=app-code>
				<h4>connect your website</h4>
				<p>copy-paste this html into your website's &lt;head&gt; section:</p>
				<code class=htmlcode>
					${renderXiomeConfig(appId)}
				</code>
				<p>then head over to the <a part=link href="./components">components page</a></p>
			</div>
		`;
        }
        renderApp(app) {
            const appState = this.getAppState(app.appId);
            return $ `
			<div class=app data-app-id=${app.appId}>

				<div class=app-header part=app-header>
					<div class=title>
						<h3>
							<a part=link target=_blank href="${app.home}">
								${app.label}
							</a>
						</h3>
					</div>
					<div class=stats>
						<div data-stat=users>
							<span>${app.stats.users.toLocaleString()}</span>
							<span>users</span>
						</div>
						<div data-stat=monthly-active>
							<span>${app.stats.usersActiveMonthly.toLocaleString()}</span>
							<span>monthly active</span>
						</div>
						<div data-stat=active-last-day>
							<span>${app.stats.usersActiveDaily.toLocaleString()}</span>
							<span>daily active</span>
						</div>
					</div>
				</div>

				<div class=twoside>
					${this.renderAppCode(app.appId)}
					<div class=editside>
						<div class=buttons>
							<xio-button @click=${appState.toggleEditMode}>edit community</xio-button>
						</div>
						<div class=app-options ?hidden=${!appState.editMode}>
							<div class=app-details>
								${appState.appForm.render({ partNamespace: "appeditor" })}
							</div>
							<div class=adminmanager>
								<h4>manage admins</h4>
								${appState.adminManager.render()}
							</div>
							${this.renderAppBankLinking(app)}
							<div class=finalbox>
								<xio-button
									class=delete-app-button
									@press=${() => this.deleteApp(app)}>
										delete community
								</xio-button>
							</div>
						</div>
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { appRecords } = this.share.appsModel.state;
            return $ `
			${renderOp(appRecords, records => Object.values(records).length
            ? this.renderAppList(records)
            : this.renderNoApps())}
		`;
        }
    };
    XiomeAppManager = __decorate$f([
        mixinStyles(styles$e)
    ], XiomeAppManager);

    var styles$d = r$2 `

:host {
	display: block;
	width: var(--avatar-size, 2em);
	height: var(--avatar-size, 2em);
	--op-size: calc(var(--avatar-size, 2em) * 0.5);
}

xio-op {
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100%;
	height: 100%;
}

:host([logged-in]) .avatar {
	color: #fff;
}

`;

    var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAvatar = class XiomeMyAvatar extends mixinRequireShare()(Component) {
        render() {
            const accessOp = this.share.accessModel.getAccessOp();
            return renderOp(accessOp, access => {
                var _a;
                return $ `
				<xio-avatar
					part=avatar
					.spec=${(_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.profile.avatar}
				></xio-avatar>
			`;
            }, null, { showErrorText: false });
        }
    };
    XiomeMyAvatar = __decorate$e([
        mixinStyles(styles$d)
    ], XiomeMyAvatar);

    var styles$c = r$2 `

xio-profile-card {
	--avatar-size: 7em;
}

`;

    var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeMyAccount = class XiomeMyAccount extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.saveProfile = async (profileDraft) => {
                await this.share.personalModel.saveProfile(profileDraft);
            };
        }
        render() {
            const { accessOp } = this.share.personalModel.readable;
            return renderOp(accessOp, ({ user }) => $ `
			<xio-profile-card
				show-details
				.user=${user}
				.saveProfile=${this.saveProfile}
			></xio-profile-card>
		`);
        }
    };
    XiomeMyAccount = __decorate$d([
        mixinStyles(styles$c)
    ], XiomeMyAccount);

    var styles$b = r$2 `

:host {
	display: block;
}

slot {
	display: block;
}

xio-text-input,
xio-button {
	margin-top: 0.2em;
}

xio-text-input > span {
	opacity: 0.4;
	font-size: 0.7em;
}

.buttonbar {
	margin-top: 0.5em;
	vertical-align: middle;
}

slot[name="legal"] {
	display: inline-block;
	margin: 0 1em;
}

small {
	display: block;
	opacity: 0.5;
	font-size: 0.7em;
}

`;

    var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeLoginPanel = class XiomeLoginPanel extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this["show-logout"] = false;
            this["status"] = "loading";
            this.sentLoading = ops.none();
            this.emailIsValid = false;
        }
        async sendEmail() {
            const email = this.textInput.value;
            await ops.operation({
                promise: this.share.accessModel.sendLoginLink(email)
                    .then(() => ({ email })),
                setOp: op => this.sentLoading = op,
                errorReason: `failed sending email to "${email}"`,
            });
        }
        resetSentLoading() {
            this.sentLoading = ops.none();
            if (this.textInput)
                this.textInput.text = "";
        }
        logout() {
            this.share.accessModel.logout()
                .then(() => this.sentLoading = ops.none());
        }
        subscribe() {
            return this.share.accessModel.subscribe(() => {
                this.resetSentLoading();
            });
        }
        renderLoggedIn(access) {
            return $ `
			<slot>
				<p>Welcome ${access.user.profile.nickname}!</p>
			</slot>
			${this["show-logout"]
            ? $ `
					<div part=buttonbar>
						<xio-button class=logout-button @press=${this.logout}>
							Logout
						</xio-button>
					</div>
				`
            : null}
		`;
        }
        handleEmailChange() {
            this.emailIsValid = this.textInput.problems.length === 0;
        }
        renderLegalLink() {
            return $ `
			<small>
				<p>
					<a
						part=link
						target=_blank
						href="https://xiome.io/legal">
							policies and terms
					</a>
				</p>
			</small>
		`;
        }
        renderLoggedOut() {
            const { emailIsValid } = this;
            return $ `
			<xio-op .op=${this.sentLoading}>
				<div slot=none>
					<slot name=logged-out>
						<p>login with your email address</p>
					</slot>
					<xio-text-input
						.validator=${email()}
						@valuechange=${this.handleEmailChange}
						@enterpress=${this.sendEmail}>
							<span>your email</span>
					</xio-text-input>
					<div class=buttonbar>
						<slot name=legal>
							${this.renderLegalLink()}
						</slot>
						<xio-button
							?disabled=${!emailIsValid}
							@press=${this.sendEmail}>
								send login link
						</xio-button>
					</div>
				</div>
				${ops.isReady(this.sentLoading)
            ? $ `
						<p>email sent to ${ops.value(this.sentLoading).email}</p>
						<p>please wait a few minutes for it to arrive</p>
						<xio-button @press=${this.resetSentLoading}>
							restart
						</xio-button>
					`
            : null}
			</xio-op>
		`;
        }
        render() {
            var _a;
            const accessOp = this.share.accessModel.getAccessOp();
            this.status = "loading";
            if (ops.isReady(accessOp)) {
                this.status = ((_a = ops.value(accessOp)) === null || _a === void 0 ? void 0 : _a.user)
                    ? "logged-in"
                    : "logged-out";
            }
            return renderOp(accessOp, access => (access === null || access === void 0 ? void 0 : access.user)
                ? this.renderLoggedIn(access)
                : this.renderLoggedOut());
        }
    };
    __decorate$c([
        e({ type: Boolean, reflect: true })
    ], XiomeLoginPanel.prototype, "show-logout", void 0);
    __decorate$c([
        e({ type: String, reflect: true })
    ], XiomeLoginPanel.prototype, "status", void 0);
    __decorate$c([
        e()
    ], XiomeLoginPanel.prototype, "sentLoading", void 0);
    __decorate$c([
        i("xio-text-input")
    ], XiomeLoginPanel.prototype, "textInput", void 0);
    __decorate$c([
        e({ type: String })
    ], XiomeLoginPanel.prototype, "emailIsValid", void 0);
    XiomeLoginPanel = __decorate$c([
        mixinStyles(styles$b)
    ], XiomeLoginPanel);

    var styles$a = r$2 `

.creator {
	margin: 1em auto;
}

.privilege {
	display: inline-flex;
	flex-direction: row;
	padding: 0.2em 0.5em;
	margin: 0.2em;
	border: 1px solid;
}

.privilege .icon {
	padding-right: 0.5em;
}

.privilege xio-button {
	--xio-button-padding: 0;
	--xio-button-border: none;
}

.privilege[data-hard] {
	opacity: 0.5;
	border: 1px solid dashed;
}

`;

    var wrenchSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><g fill="none"><path d="M7 5a4 4 0 0 1 5.445-3.73a.5.5 0 0 1 .173.819L10.708 4L12 5.293l1.91-1.91a.5.5 0 0 1 .82.172a4 4 0 0 1-4.829 5.292L4.897 13.92a1.986 1.986 0 0 1-2.843-2.774l5.051-5.234A4.01 4.01 0 0 1 7 5zm4-3a3 3 0 0 0-2.862 3.903a.5.5 0 0 1-.117.498L2.773 11.84a.986.986 0 0 0 1.41 1.377l5.225-5.293a.5.5 0 0 1 .532-.116a3 3 0 0 0 4.046-3.088l-1.633 1.634a.5.5 0 0 1-.707 0l-2-2a.5.5 0 0 1 0-.707l1.634-1.634A3.045 3.045 0 0 0 11 2z" fill="currentColor"/></g></svg>`;

    var cancelSvg = y `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill="currentColor" fill-rule="evenodd" d="M7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm0 1.3c1.3 0 2.5.44 3.47 1.17l-8 8A5.755 5.755 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zm0 11.41c-1.3 0-2.5-.44-3.47-1.17l8-8c.73.97 1.17 2.17 1.17 3.47 0 3.14-2.56 5.7-5.7 5.7z"/></svg>`;

    function renderPrivilege({ privilege: { hard, label, privilegeId }, onDeleteClick, }) {
        function renderSystemIcon() {
            return $ `
			<div class="icon system">
				${wrenchSvg}
			</div>
		`;
        }
        function renderDeleteButton() {
            return $ `
			<xio-button
				title="delete privilege"
				class="icon delete"
				@press=${onDeleteClick}>
					${cancelSvg}
			</xio-button>
		`;
        }
        return $ `
		<div
			class=privilege
			?data-hard=${hard}>
				${hard ? renderSystemIcon() : renderDeleteButton()}
				<span class=text>${label}</span>
		</div>
	`;
    }

    const validatePermissionsLabel = validator(string(), minLength(1), maxLength(32));

    var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldSet$4 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$7 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomePrivileges_instances, _XiomePrivileges_busy, _XiomePrivileges_clearCreatorTextInput, _XiomePrivileges_createPrivilege, _XiomePrivileges_deletePrivilege, _XiomePrivileges_labelDraft, _XiomePrivileges_handleCreatorLabelChange, _XiomePrivileges_renderPrivilegeCreator;
    let XiomePrivileges = class XiomePrivileges extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomePrivileges_instances.add(this);
            _XiomePrivileges_busy.set(this, false);
            _XiomePrivileges_labelDraft.set(this, void 0);
            _XiomePrivileges_handleCreatorLabelChange.set(this, (event) => {
                __classPrivateFieldSet$4(this, _XiomePrivileges_labelDraft, event.detail.value, "f");
                this.requestUpdate();
            });
        }
        get model() {
            return this.share.permissionsModel;
        }
        init() {
            this.model.initialize();
        }
        render() {
            const { readable: { permissionsDisplay } } = this.model;
            const allowed = this.model.getUserCanCustomizePermissions();
            return renderOp(permissionsDisplay, permissions => allowed ? $ `
			<div class=privileges>
				${__classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_renderPrivilegeCreator).call(this)}
				${permissions.privileges.map(privilege => renderPrivilege({
            privilege,
            onDeleteClick: () => __classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_deletePrivilege).call(this, privilege)
        }))}
			</div>
		` : $ `
			<p>you are not permitted to customize privileges</p>
		`);
        }
    };
    _XiomePrivileges_busy = new WeakMap(), _XiomePrivileges_labelDraft = new WeakMap(), _XiomePrivileges_handleCreatorLabelChange = new WeakMap(), _XiomePrivileges_instances = new WeakSet(), _XiomePrivileges_clearCreatorTextInput = function _XiomePrivileges_clearCreatorTextInput() {
        const input = this.shadowRoot.querySelector(".creator xio-text-input");
        input.text = "";
    }, _XiomePrivileges_createPrivilege = async function _XiomePrivileges_createPrivilege() {
        if (__classPrivateFieldGet$7(this, _XiomePrivileges_busy, "f"))
            throw new Error("privilege creator is busy");
        const label = __classPrivateFieldGet$7(this, _XiomePrivileges_labelDraft, "f");
        __classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_clearCreatorTextInput).call(this);
        __classPrivateFieldSet$4(this, _XiomePrivileges_busy, true, "f");
        try {
            await this.model.createPrivilege({ label });
        }
        finally {
            __classPrivateFieldSet$4(this, _XiomePrivileges_busy, false, "f");
        }
    }, _XiomePrivileges_deletePrivilege = async function _XiomePrivileges_deletePrivilege({ privilegeId, label }) {
        const confirm = await this.share.modals.confirm({
            title: $ `delete privilege ${label}?`,
            body: $ `are you sure you want to delete this privilege?`,
        });
        if (confirm)
            await this.model.deletePrivilege({ privilegeId });
    }, _XiomePrivileges_renderPrivilegeCreator = function _XiomePrivileges_renderPrivilegeCreator() {
        const isCreateButtonDisabled = !__classPrivateFieldGet$7(this, _XiomePrivileges_labelDraft, "f");
        return $ `
			<div class=creator>
				<xio-text-input
					?disabled=${__classPrivateFieldGet$7(this, _XiomePrivileges_busy, "f")}
					.validator=${validatePermissionsLabel}
					@valuechange=${__classPrivateFieldGet$7(this, _XiomePrivileges_handleCreatorLabelChange, "f")}
					@enterpress=${__classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_createPrivilege)}>
						privilege label
				</xio-text-input>
				<xio-button
					?disabled=${isCreateButtonDisabled}
					@press=${__classPrivateFieldGet$7(this, _XiomePrivileges_instances, "m", _XiomePrivileges_createPrivilege)}>
						create privilege
				</xio-button>
			</div>
		`;
    };
    XiomePrivileges = __decorate$b([
        mixinStyles(styles$a)
    ], XiomePrivileges);

    var styles$9 = r$2 `

* {
	ZZoutline: 1px solid #0f02;
}

:host {
	display: block;
	width: 100%;
}

.container {
	display: flex;
	flex-direction: row;
	flex-wrap: wrap;
	gap: 0.5em;
}

.container > * {
	flex: 3 1 10em;
	display: flex;
	flex-direction: column;
}

.roles {
	flex: 1 3 10em;
}

.roles xio-button[data-hard] {
	opacity: 0.6;
}

.container > * > p {
	padding: 0 0.5em;
}

[part=plate] {
	flex: 1 1 auto;
	padding: 0.5em;
	background: #fff2;
}

[part=plate] xio-button {
	display: inline-block;
	margin: 0.2em 0.1em;
	--xio-button-disabled-opacity: 0.6;
}

[part=plate] xio-button[data-hard] {
	opacity: 0.6;
}

[part=plate] xio-button[data-selected]::part(button) {
	border: 1px solid lime;
	background: yellow;
	color: black;
}

[part=plate] xio-button > div {
	display: flex;
	flex-direction: row;
}

[part=plate] xio-button .icon {
	margin-right: 0.2em;
}

[part=plate] xio-button svg {
	width: 0.8em;
	height: 0.8em;
}

.buttonbar {
	text-align: right;
	background: #0002;
}

.buttonbar [data-button=delete] {
	--xio-button-hover-color: red;
	--xio-button-hover-background: transparent;
}

.buttonbar [data-button=new] {
	--xio-button-hover-color: lime;
	--xio-button-hover-background: transparent;
}

`;

    var lockSvg = y `<svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-lock"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>`;

    const roleLabelValidator = validator(string(), minLength(1), maxLength(16), notWhitespace());

    var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomePermissions = class XiomePermissions extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.clickRole = (role) => () => {
                this.roleSelected = role;
            };
            this.clickDeleteRole = async () => {
                const { modals, permissionsModel } = this.share;
                const role = this.roleSelected;
                const confirmed = await modals.confirm({
                    title: "Delete role?",
                    body: `Are you sure you want to permanently delete the role "${role.label}"`,
                    yes: { vibe: "negative", label: "Delete role" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                });
                if (confirmed)
                    await permissionsModel.deleteRole({ roleId: role.roleId });
            };
            this.clickNewRole = async () => {
                const { modals, permissionsModel } = this.share;
                const result = await modals.prompt({
                    title: "Create a new role",
                    input: {
                        label: "Role name",
                        validator: roleLabelValidator,
                    },
                    yes: { vibe: "positive", label: "Create role" }
                });
                if (result)
                    await permissionsModel.createRole({ label: result.value });
            };
            this.clickAvailablePrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.assignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
            this.clickAssignedPrivilege = (privilegeId) => async () => {
                const { roleSelected } = this;
                if (roleSelected)
                    await this.share.permissionsModel.unassignPrivilege({
                        privilegeId,
                        roleId: roleSelected.roleId,
                    });
            };
        }
        init() {
            this.share.permissionsModel.initialize();
        }
        getAssignedPrivileges(permissions) {
            const { roleSelected } = this;
            if (!roleSelected)
                return [];
            const assignedPrivilegeIds = permissions.rolesHavePrivileges
                .filter(({ roleId }) => roleId === roleSelected.roleId)
                .map(({ privilegeId }) => privilegeId);
            return permissions.privileges
                .filter(({ privilegeId }) => assignedPrivilegeIds.includes(privilegeId))
                .map(privilege => {
                const { active, immutable } = permissions.rolesHavePrivileges.find(rp => rp.roleId === roleSelected.roleId &&
                    rp.privilegeId === privilege.privilegeId);
                return { ...privilege, active, immutable };
            });
        }
        renderPrivilege({ privilegeId, label, hard, immutable, onPrivilegeClick, }) {
            return $ `
			<xio-button
				title="${privilegeId}"
				?disabled=${immutable}
				?data-hard=${hard}
				?data-soft=${!hard}
				?data-immutable=${immutable}
				@press=${onPrivilegeClick}>
					<div>
						${hard
            ? $ `<div class=icon>${wrenchSvg}</div>`
            : null}
						${immutable
            ? $ `<div class=icon>${lockSvg}</div>`
            : null}
						${label}
					</div>
			</xio-button>
		`;
        }
        renderPermissions(permissions) {
            const assignedPrivileges = this.getAssignedPrivileges(permissions);
            const activePrivileges = assignedPrivileges.filter(p => p.active);
            const availablePrivileges = this.roleSelected
                ? [
                    ...permissions.privileges
                        .filter(privilege => {
                        const assigned = assignedPrivileges
                            .find(priv => priv.privilegeId === privilege.privilegeId);
                        return !assigned;
                    })
                        .map(privilege => ({ ...privilege, immutable: false })),
                    ...assignedPrivileges
                        .filter(privilege => !privilege.active)
                ]
                : [];
            return $ `
			<div class=container>
				<div class=roles>
					<p>roles</p>
					<div part=plate>
						${permissions.roles.map(role => $ `
							<xio-button
								title="${role.roleId}"
								?data-selected=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								?data-hard=${role.hard}
								?disabled=${this.roleSelected &&
            role.roleId === this.roleSelected.roleId}
								@click=${this.clickRole(role)}>
								<div>
									${role.hard
            ? $ `<div class=icon>${wrenchSvg}</div>`
            : null}
									${role.label}
								</div>
							</xio-button>
						`)}
					</div>
					<div part=plate class=buttonbar>
						${this.roleSelected
            ? $ `
								<xio-button
									data-button=delete
									?disabled=${this.roleSelected.hard}
									@press=${this.clickDeleteRole}>
										delete role
								</xio-button>
							`
            : null}
						<xio-button data-button=new @press=${this.clickNewRole}>
							new role
						</xio-button>
					</div>
				</div>

				<div class=assigned>
					<p>
						privileges assigned
						${this.roleSelected
            ? ` to "${this.roleSelected.label}"`
            : null}
					</p>
					<div part=plate>
						${activePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAssignedPrivilege(privilege.privilegeId)
        }))}
					</div>
				</div>

				<div class=available>
					<p>privileges available</p>
					<div part=plate>
						${availablePrivileges.map(privilege => this.renderPrivilege({
            ...privilege,
            onPrivilegeClick: this.clickAvailablePrivilege(privilege.privilegeId),
        }))}
					</div>
				</div>
			</div>
		`;
        }
        render() {
            const { permissionsModel } = this.share;
            const { getUserCanCustomizePermissions, readable } = permissionsModel;
            return getUserCanCustomizePermissions()
                ? renderOp(readable.permissionsDisplay, this.renderPermissions.bind(this))
                : $ `
				<p>you are not privileged to customize permissions</p>
			`;
        }
    };
    __decorate$a([
        e()
    ], XiomePermissions.prototype, "roleSelected", void 0);
    XiomePermissions = __decorate$a([
        mixinStyles(styles$9)
    ], XiomePermissions);

    function integrateAuthComponents({ models, modals }) {
        const { accessModel, appsModel, personalModel, permissionsModel } = models;
        return {
            XiomeMyAvatar: mixinSnapstateSubscriptions(accessModel.subscribe)(mixinShare({
                accessModel,
            })(XiomeMyAvatar)),
            XiomeLoginPanel: mixinSnapstateSubscriptions(accessModel.subscribe)(mixinShare({
                accessModel,
            })(XiomeLoginPanel)),
            XiomeAppManager: mixinSnapstateSubscriptions(appsModel.subscribe)(mixinShare({
                modals,
                appsModel,
            })(XiomeAppManager)),
            XiomeMyAccount: mixinSnapstateSubscriptions(personalModel.subscribe)(mixinShare({
                personalModel,
            })(XiomeMyAccount)),
            XiomePermissions: mixinSnapstateSubscriptions(permissionsModel.subscribe)(mixinShare({
                modals,
                permissionsModel,
            })(XiomePermissions)),
            XiomePrivileges: mixinSnapstateSubscriptions(permissionsModel.subscribe)(mixinShare({
                modals,
                permissionsModel,
            })(XiomePrivileges)),
        };
    }

    var usersSvg = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-users"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>`;

    var clearIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-trash"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;

    var unmuteIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`;

    var onOffIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-power"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>`;

    function pluralize(length, singular, plural) {
        return length === 1 ?
            singular :
            plural;
    }

    var muteIcon = y `
<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-volume-x"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>`;

    var deleteIcon = y `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x-circle"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;

    function renderChatPost({ post, isModerator, mute, remove, mutedIds, }) {
        const postTime = formatDate(post.time);
        const userIsMuted = mutedIds.includes(post.userId);
        return $ `
		<li data-post="${post.postId}">
			<header>
				<span class=nickname>${post.nickname}</span>
				${isModerator
        ? $ `
						<span class=moderation>
							<xio-button
								title="mute user"
								@press=${mute}
								?disabled=${userIsMuted}>
									${muteIcon}
							</xio-button>
							<xio-button
								title="delete post"
								@press=${remove}>
									${deleteIcon}
							</xio-button>
						</span>
					`
        : null}
				<xio-id class=userid title="copy user id" id="${post.userId}"></xio-id>
			</header>
			<div>
				<p class=content>
					${post.content}
					<span class=time title="${postTime.date} ${postTime.zone}">
						${postTime.time}
					</span>
				</p>
			</div>
		</li>
	`;
    }

    const validateChatContent = validator(string(), minLength(1), maxLength(chatPostMaxLength), notWhitespace());

    function renderChatAuthorship({ sendable, onSendClick, onEnterPress, onValidityChange, }) {
        function handleContentChange(event) {
            const value = event.detail.value;
            onValidityChange(value !== undefined);
        }
        return $ `
		<div class=authorship>

			<xio-text-input
				textarea
				.validator=${validateChatContent}
				@valuechange=${handleContentChange}
				@enterpress=${onEnterPress}>
			</xio-text-input>

			<xio-button
				?disabled=${!sendable}
				@press=${onSendClick}>
					send message
			</xio-button>
		</div>
	`;
    }

    var chatHistoryCss = r$2 `

.history ol,
.history slot[name="no-messages"] {
	height: var(--xiome-chat-history-height);
	overflow-y: auto;
	scrollbar-color: #0004 #0002;
	scrollbar-width: thin;
}

.history ol::-webkit-scrollbar {
	width: 0.4em;
}

.history ol::-webkit-scrollbar-thumb {
	border-radius: 1em;
	background: #0004;
}

.history ol::-webkit-scrollbar-thumb:hover {
	background: #0008;
}

.history ol::-webkit-scrollbar-thumb:active {
	background: #000a;
}

.history ol::-webkit-scrollbar-track {
	border-radius: 1em;
	background: #0002;
}

slot[name="no-messages"] {
	opacity: 0.5;
	display: flex;
	justify-content: center;
	align-items: center;
	text-align: center;
}

.history li + li {
	margin-top: 0.75em;
}

.history li > header {
	display: flex;
	flex-direction: row;
	align-items: center;
	gap: 0.5em;
}

.history li .moderation {
	opacity: 0.5;
}

.history li > header > span {
	display: flex;
	align-items: center;
}

.history li > header > span > xio-button {
	--xio-button-border: none;
	--xio-button-padding: 0 0.3em;
}

.history li .nickname {
	font-size: 1em;
	opacity: var(--xio-chat-nickname-opacity, 0.5);
	color: var(--xio-chat-nickname-color, currentColor);
}

.history li .userid {
	font-size: 1em;
	opacity: var(--xio-chat-userid-opacity, 0.5);
	color: var(--xio-chat-userid-color, currentColor);
}

.history li .content {
	font-size: 1.3em;
	word-break: break-word;
}

.history li .time {
	opacity: 0.3;
	font-size: 1rem;
}

`;

    var xiomeChatCss = r$2 `

:host {
	display: block;
	max-width: 56em;
	--xiome-chat-history-height: 20em;
}

.modheader {
	display: flex;
	flex-wrap: wrap;
	flex-direction: row;
	align-items: end;
	padding: 0 1em;
}

.modheader > span:nth-child(1) {
	opacity: 0.5;
	padding: 0.2em 0;
}

.modheader > span:nth-child(2) {
	margin-left: auto;
}

xio-button {
	--xio-button-disabled-border-style: none;
}

.modheader xio-button {
	--xio-button-border: none;
}

.modheader xio-button::part(button-slot) {
	display: flex;
	align-items: center;
	gap: 0.5em;
}

.history {
	padding: 1em;
	border: 1px solid;
	border-radius: 0.5em 0.5em 0 0;
	border-bottom: 0;
}

.chatbox xiome-login-panel {
	display: block;
	border: 1px solid currentColor;
	border-radius: 0 0 0.5em 0.5em;
}

.chatbox xiome-login-panel[status="logged-out"] {
	padding: 1em;
}

.chatbox slot[name="offline"],
.chatbox slot[name="muted"] {
	display: block;
	padding: 2em 1em;
	text-align: center;
}

.chatbox slot[name="offline"] {
	border: 1px solid currentColor;
	border-radius: 0.5em;
}

.chatfooter {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	margin: 0.1em 0.5em;
}

.chatfooter svg {
	width: 1.3em;
}

.chatfooter .user-count {
	margin: 0 0.5em;
}

.chatfooter .user-counting-details {
	opacity: 0.5;
}

${chatHistoryCss}

.authorship {
	display: flex;
	align-items: stretch;
	Xborder: 1px solid;
}

.authorship xio-text-input {
	border-right: 1px solid;
	--xio-text-input-height: 6em;
	--xio-text-input-label-opacity: 0.5;
	--xio-text-input-border: 0;
	--xio-text-input-pad: 1em;
}

.authorship xio-button {
	height: 6em;
	flex: 1 1 auto;
	--xio-button-border: 0;
	--xio-button-disabled-border-style: none;
}

.authorship xio-button::part(button) {
	width: 100%;
}

.authorship .inputlabel {
	display: block;
	opacity: 0.5;
	padding: 0.2em 0;
	margin-left: 1em;
}

`;

    var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldSet$3 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$6 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeChat_instances, _XiomeChat_model_get, _XiomeChat_roomStats_get, _XiomeChat_room, _XiomeChat_dispose, _XiomeChat_scrolledToBottom, _XiomeChat_updateScrolledToBottom, _XiomeChat_coordinateScrollingBehavior, _XiomeChat_renderRoomStats, _XiomeChat_renderModerationHeader, _XiomeChat_renderHistory, _XiomeChat_lastSend, _XiomeChat_updateTooSoon, _XiomeChat_subscribeTooSoon, _XiomeChat_postToChat, _XiomeChat_renderParticipation;
    let XiomeChat = class XiomeChat extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeChat_instances.add(this);
            this.room = "default";
            _XiomeChat_room.set(this, void 0);
            _XiomeChat_dispose.set(this, () => { });
            _XiomeChat_scrolledToBottom.set(this, true);
            _XiomeChat_coordinateScrollingBehavior.set(this, () => {
                const ol = this.shadowRoot.querySelector(".history ol");
                if (ol) {
                    if (ol.scrollHeight <= ol.clientHeight)
                        __classPrivateFieldSet$3(this, _XiomeChat_scrolledToBottom, true, "f");
                    else if (__classPrivateFieldGet$6(this, _XiomeChat_scrolledToBottom, "f"))
                        ol.scrollTo(0, ol.scrollHeight - ol.clientHeight);
                }
                else
                    __classPrivateFieldSet$3(this, _XiomeChat_scrolledToBottom, true, "f");
            });
            this.draftValid = false;
            this.tooSoon = false;
            _XiomeChat_lastSend.set(this, Date.now());
            _XiomeChat_updateTooSoon.set(this, () => {
                const since = Date.now() - __classPrivateFieldGet$6(this, _XiomeChat_lastSend, "f");
                this.tooSoon = since < chatPostCoolOff;
            });
            _XiomeChat_postToChat.set(this, (event) => {
                event.preventDefault();
                const { tooSoon } = this;
                if (!tooSoon) {
                    const { value } = this.authorshipInput;
                    const draft = { content: value };
                    __classPrivateFieldSet$3(this, _XiomeChat_lastSend, Date.now(), "f");
                    this.authorshipInput.text = "";
                    __classPrivateFieldGet$6(this, _XiomeChat_updateTooSoon, "f").call(this);
                    __classPrivateFieldGet$6(this, _XiomeChat_room, "f").post(draft);
                }
            });
        }
        subscribe() {
            __classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).session(this.room)
                .then(({ room, dispose }) => {
                __classPrivateFieldSet$3(this, _XiomeChat_room, room, "f");
                __classPrivateFieldSet$3(this, _XiomeChat_dispose, dispose, "f");
            })
                .then(() => this.requestUpdate());
            const unsubs = [
                super.subscribe(),
                () => __classPrivateFieldGet$6(this, _XiomeChat_dispose, "f").call(this),
                __classPrivateFieldGet$6(this, _XiomeChat_instances, "m", _XiomeChat_subscribeTooSoon).call(this),
                __classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).subscribeToChange(__classPrivateFieldGet$6(this, _XiomeChat_coordinateScrollingBehavior, "f")),
            ];
            return () => {
                for (const unsub of unsubs)
                    unsub();
            };
        }
        render() {
            return renderOp(__classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.connectionOp, () => {
                var _a;
                return $ `
			<div class=chatbox>
				${__classPrivateFieldGet$6(this, _XiomeChat_room, "f") ?
                $ `
						${__classPrivateFieldGet$6(this, _XiomeChat_instances, "m", _XiomeChat_renderModerationHeader).call(this)}
						${((_a = __classPrivateFieldGet$6(this, _XiomeChat_room, "f")) === null || _a === void 0 ? void 0 : _a.status) === ChatStatus.Online
                    ? [
                        __classPrivateFieldGet$6(this, _XiomeChat_instances, "m", _XiomeChat_renderHistory).call(this),
                        __classPrivateFieldGet$6(this, _XiomeChat_instances, "m", _XiomeChat_renderParticipation).call(this),
                        __classPrivateFieldGet$6(this, _XiomeChat_instances, "m", _XiomeChat_renderRoomStats).call(this)
                    ]
                    : $ `
								<slot name=offline>
									chat is offline
								</slot>
							`}
					` :
                null}
			</div>
		`;
            });
        }
    };
    _XiomeChat_room = new WeakMap(), _XiomeChat_dispose = new WeakMap(), _XiomeChat_scrolledToBottom = new WeakMap(), _XiomeChat_coordinateScrollingBehavior = new WeakMap(), _XiomeChat_lastSend = new WeakMap(), _XiomeChat_updateTooSoon = new WeakMap(), _XiomeChat_postToChat = new WeakMap(), _XiomeChat_instances = new WeakSet(), _XiomeChat_model_get = function _XiomeChat_model_get() {
        return this.share.chatModel;
    }, _XiomeChat_roomStats_get = function _XiomeChat_roomStats_get() {
        var _a;
        const statsForRooms = (_a = __classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.cache.roomStats) === null || _a === void 0 ? void 0 : _a.statsForRooms;
        if (statsForRooms) {
            return statsForRooms[this.room];
        }
    }, _XiomeChat_updateScrolledToBottom = function _XiomeChat_updateScrolledToBottom() {
        const ol = this.shadowRoot.querySelector("ol");
        const { scrollTop, scrollHeight, clientHeight } = ol;
        const scrollTotal = scrollHeight - clientHeight;
        const scrollFromBottom = scrollTotal - scrollTop;
        __classPrivateFieldSet$3(this, _XiomeChat_scrolledToBottom, scrollFromBottom < 50, "f");
    }, _XiomeChat_renderRoomStats = function _XiomeChat_renderRoomStats() {
        const roomStats = __classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_roomStats_get);
        if (roomStats) {
            const { moderators, viewers, participants, totalUsers } = roomStats;
            return __classPrivateFieldGet$6(this, _XiomeChat_room, "f")
                ? $ `
					<p class=chatfooter>
						${usersSvg}
						<span class=user-count>
							${totalUsers} ${pluralize(totalUsers, "user", "users")}
						</span>
						<span class=user-counting-details>
							(${moderators} ${pluralize(moderators, "moderator", "moderators")},
							${participants} ${pluralize(participants, "participant", "participants")},
							${viewers} ${pluralize(viewers, "viewer", "viewers")})
						</span>
					</p>
				`
                : null;
        }
    }, _XiomeChat_renderModerationHeader = function _XiomeChat_renderModerationHeader() {
        const status = __classPrivateFieldGet$6(this, _XiomeChat_room, "f").status;
        const toggleStatus = () => {
            __classPrivateFieldGet$6(this, _XiomeChat_room, "f").setRoomStatus(__classPrivateFieldGet$6(this, _XiomeChat_room, "f").status === ChatStatus.Offline
                ? ChatStatus.Online
                : ChatStatus.Offline);
        };
        const muteCount = __classPrivateFieldGet$6(this, _XiomeChat_room, "f").muted.length;
        return __classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.moderateAllChats
            ? $ `
				<header class=modheader>
					<span>room="${this.room}"</span>
					<span>
						<xio-button
							title="unmute ${muteCount} users"
							?disabled=${muteCount === 0}
							@press=${() => __classPrivateFieldGet$6(this, _XiomeChat_room, "f").unmuteAll()}>
								${unmuteIcon} ${muteCount}
						</xio-button>
						<xio-button
							title="clear chat room"
							@press=${() => __classPrivateFieldGet$6(this, _XiomeChat_room, "f").clear()}>
								${clearIcon}
						</xio-button>
						<xio-button
							title="set chat ${status === ChatStatus.Offline ? "online" : "offline"}"
							@press=${toggleStatus}>
								${onOffIcon}
						</xio-button>
					</span>
				</header>
			`
            : null;
    }, _XiomeChat_renderHistory = function _XiomeChat_renderHistory() {
        return $ `
			<div class=history>
				${__classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.viewAllChats
        ? $ `
						${__classPrivateFieldGet$6(this, _XiomeChat_room, "f").posts.length
            ? $ `
								<ol @scroll=${__classPrivateFieldGet$6(this, _XiomeChat_instances, "m", _XiomeChat_updateScrolledToBottom)}>
									${__classPrivateFieldGet$6(this, _XiomeChat_room, "f").posts.map(post => renderChatPost({
                post,
                isModerator: __classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.moderateAllChats,
                mute: () => __classPrivateFieldGet$6(this, _XiomeChat_room, "f").mute(post.userId),
                remove: () => __classPrivateFieldGet$6(this, _XiomeChat_room, "f").remove([post.postId]),
                mutedIds: __classPrivateFieldGet$6(this, _XiomeChat_room, "f").muted
            }))}
								</ol>
							`
            : $ `
								<slot name=no-messages>
									no messages
								</slot>
							`}
					`
        : $ `
						<slot name=cannot-view>
							you are not privileged to view the chat
						</slot>
					`}
			</div>
		`;
    }, _XiomeChat_subscribeTooSoon = function _XiomeChat_subscribeTooSoon() {
        const interval = setInterval(__classPrivateFieldGet$6(this, _XiomeChat_updateTooSoon, "f"), 1000);
        return () => clearInterval(interval);
    }, _XiomeChat_renderParticipation = function _XiomeChat_renderParticipation() {
        const authorshipArea = () => {
            return __classPrivateFieldGet$6(this, _XiomeChat_room, "f").weAreBanned
                ? $ `<slot name=banned>you are banned</slot>`
                : __classPrivateFieldGet$6(this, _XiomeChat_room, "f").weAreMuted
                    ? $ `<slot name=muted>you are muted</slot>`
                    : renderChatAuthorship({
                        sendable: !!this.draftValid && !this.tooSoon,
                        onSendClick: __classPrivateFieldGet$6(this, _XiomeChat_postToChat, "f"),
                        onEnterPress: __classPrivateFieldGet$6(this, _XiomeChat_postToChat, "f"),
                        onValidityChange: valid => this.draftValid = valid,
                    });
        };
        return $ `
			<xiome-login-panel>
				${whenOpReady(__classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).state.accessOp, () => $ `
					<slot name=logged-out slot=logged-out>
						login to participate in the chat
					</slot>
					<div class=participation>
						${__classPrivateFieldGet$6(this, _XiomeChat_instances, "a", _XiomeChat_model_get).allowance.participateInAllChats
        ? authorshipArea()
        : $ `
								<slot name=cannot-participate>
									you do not have privilege to participate in the chat
								</slot>
							`}
					</div>
				`)}
			</xiome-login-panel>
		`;
    };
    __decorate$9([
        e({ type: String })
    ], XiomeChat.prototype, "room", void 0);
    __decorate$9([
        e()
    ], XiomeChat.prototype, "draftValid", void 0);
    __decorate$9([
        i(".authorship xio-text-input")
    ], XiomeChat.prototype, "authorshipInput", void 0);
    __decorate$9([
        e()
    ], XiomeChat.prototype, "tooSoon", void 0);
    XiomeChat = __decorate$9([
        mixinStyles(xiomeChatCss)
    ], XiomeChat);

    function integrateChatComponents({ models, modals }) {
        const { chatModel } = models;
        return {
            XiomeChat: (mixinSnapstateSubscriptions(chatModel.subscribe)(mixinShare({
                modals,
                chatModel,
            })(XiomeChat))),
        };
    }

    var styles$8 = r$2 `

:host {
	display: flex;
	flex-direction: column;
	align-items: stretch;
	justify-content: center;
	max-width: 32em;
	border: solid 0.1em;
}

xio-button {
	--xio-button-border: none;
	--_disabled-border-style: none;
}

/* Note tabs new/old */

.tabs {
	display: flex;
	justify-content: space-evenly;
	padding-bottom: 1em;
	margin: 1em 2em;
	border-bottom: solid 0.1em;
}

[data-tab] {
	font-weight: normal;
}

[data-tab][data-active='true'] {
	font-weight: bold;
	border-bottom: solid 0.2em;
}

/* Individual note */

ol > li {
	display: flex;
	flex-direction: column;
	padding: 1em;
	margin: 1em 2em;
	border: solid 0.1em;
	list-style-type: none;
}

ol > li > header {
	display: flex;
	justify-content: space-between;
	align-self: flex-end;
	width: 100%;
}

ol > li > p {
	opacity: 0.6;
}

/* Pagination */

.paginationBar {
	display: flex;
	justify-content: center;
	align-items: center;
	margin: 1em 2em;
}

.paginationBar > span {
	margin: 0em 1em;
}

/* Notifications */

xio-op[mode="loading"], slot {
	display: block;
	text-align: center;
	width: 100%;
	margin-bottom: 1em;
}

/* Button bar */

.buttonbar {
	display: flex;
	justify-content: flex-end;
	padding-top: 1em;
	margin: 0 2em 1em 2em;
	border-top: solid 0.1em;
}

.buttonbar > xio-button {
	--xio-button-border: solid 0.1em;
}
`;

    var chevronLeft = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-left"><polyline points="15 18 9 12 15 6"></polyline></svg>`;

    var chevronRight = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg>`;

    var plus = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;

    var cross = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;

    const second = 1000;
    const minute = 60 * second;
    const hour = 60 * minute;
    const day = 24 * hour;

    const plural = (x) => x === 1 ? "" : "s";
    function formatDuration(milliseconds) {
        const extract = (x) => {
            const result = Math.floor(milliseconds / x);
            milliseconds %= x;
            return result;
        };
        const days = extract(day);
        const hours = extract(hour);
        const minutes = extract(minute);
        const seconds = extract(second);
        const readable = {
            days: `${days} day${plural(days)}`,
            hours: `${hours} hour${plural(hours)}`,
            minutes: `${minutes} minute${plural(minutes)}`,
            seconds: `${seconds} second${plural(seconds)}`,
        };
        const ago = days > 3
            ? `${readable.days} ago`
            : days > 1
                ? `${readable.days} and ${readable.hours} ago`
                : hours > 3
                    ? `${readable.hours} ago`
                    : hours > 1
                        ? `${readable.hours} and ${readable.minutes} ago`
                        : minutes > 3
                            ? `${readable.minutes} ago`
                            : minutes > 1
                                ? `${readable.minutes} and ${readable.seconds} ago`
                                : `${readable.seconds} ago`;
        return {
            ...readable,
            ago,
        };
    }

    var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$5 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeNotes_instances, _XiomeNotes_model, _XiomeNotes_cacheDetails, _XiomeNotes_cache, _XiomeNotes_renderTabs, _XiomeNotes_renderNotes, _XiomeNotes_renderPagination, _XiomeNotes_renderButtonbar, _XiomeNotes_renderBasedOnStateOfNotesArray;
    let XiomeNotes = class XiomeNotes extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeNotes_instances.add(this);
            _XiomeNotes_model.set(this, this.share.notesModel);
            _XiomeNotes_cacheDetails.set(this, this.share.notesModel.createNotesCacheDetails());
            _XiomeNotes_cache.set(this, __classPrivateFieldGet$5(this, _XiomeNotes_cacheDetails, "f").cache);
        }
        async init() {
            await __classPrivateFieldGet$5(this, _XiomeNotes_model, "f").initialize();
        }
        subscribe() {
            const unsubs = [
                super.subscribe(),
                __classPrivateFieldGet$5(this, _XiomeNotes_cacheDetails, "f").setup(),
                __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f").subscribe(() => this.requestUpdate()),
            ];
            if (__classPrivateFieldGet$5(this, _XiomeNotes_model, "f").isLoggedIn) {
                __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f").fetchAppropriateNotes();
            }
            return () => unsubs.forEach(unsub => unsub());
        }
        render() {
            return renderOp(__classPrivateFieldGet$5(this, _XiomeNotes_model, "f").state.accessOp, access => (access === null || access === void 0 ? void 0 : access.user)
                ? $ `
					${__classPrivateFieldGet$5(this, _XiomeNotes_instances, "m", _XiomeNotes_renderBasedOnStateOfNotesArray).call(this)}
				`
                : $ `
					<slot name="logged-out">
						you must be logged in to see your notifications
					</slot>
				`);
        }
    };
    _XiomeNotes_model = new WeakMap(), _XiomeNotes_cacheDetails = new WeakMap(), _XiomeNotes_cache = new WeakMap(), _XiomeNotes_instances = new WeakSet(), _XiomeNotes_renderTabs = function _XiomeNotes_renderTabs() {
        const { old } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f").cacheState;
        const { switchTabNew, switchTabOld } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f");
        return $ `
			<div class=tabs>
				<xio-button
					@press=${switchTabNew}
					data-tab="new"
					data-active=${!old}>
						new
				</xio-button>
				<xio-button
					@press=${switchTabOld}
					data-tab="old"
					data-active=${old}>
						old
				</xio-button>
			</div>
		`;
    }, _XiomeNotes_renderNotes = function _XiomeNotes_renderNotes() {
        const { old, notesOp } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f").cacheState;
        const { markSpecificNoteNew, markSpecificNoteOld } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f");
        const now = Date.now();
        return renderOp(notesOp, notes => $ `
			<ol>
				${notes.map(note => $ `
					<li>
						<header class="note-header">
							<h2>${note.title}</h2>
							${old ? $ `
								<xio-button @press=${() => markSpecificNoteNew(note.noteId)}>
									${plus}
								</xio-button>
							` : $ `
								<xio-button @press=${() => markSpecificNoteOld(note.noteId)}>
									${cross}
								</xio-button>
							`}
						</header>
						<p><strong>${note.type}</strong> – <em>${formatDuration(now - note.time).ago}</em></p>
					</li>
				`)}
			</ol>
		`);
    }, _XiomeNotes_renderPagination = function _XiomeNotes_renderPagination() {
        const { pageNumber } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f").cacheState;
        const { nextPage, previousPage, totalPages, isNextPageAvailable, isPreviousPageAvailable, } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f");
        return $ `
			${(isNextPageAvailable || isPreviousPageAvailable)
        ? $ `
				<div class="paginationBar">
					<xio-button
						?disabled=${!isPreviousPageAvailable}
						@press=${previousPage}>
							${chevronLeft}
					</xio-button>
					<span>
						${pageNumber} / ${totalPages}
					</span>
					<xio-button
						?disabled=${!isNextPageAvailable}
						@press=${nextPage}>
							${chevronRight}
					</xio-button>
				</div>
				`
        : null}
		`;
    }, _XiomeNotes_renderButtonbar = function _XiomeNotes_renderButtonbar() {
        const { old } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f").cacheState;
        const { markAllNotesOld } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f");
        return $ `
			<div class=buttonbar>
				${old
        ? null
        : $ `
						<xio-button @press=${markAllNotesOld}>
							mark all old
						</xio-button>
					`}
			</div>
		`;
    }, _XiomeNotes_renderBasedOnStateOfNotesArray = function _XiomeNotes_renderBasedOnStateOfNotesArray() {
        var _a;
        const { old, notesOp } = __classPrivateFieldGet$5(this, _XiomeNotes_cache, "f").cacheState;
        return $ `
			${((_a = ops.value(notesOp)) === null || _a === void 0 ? void 0 : _a.length) === 0
        ? $ `
					${__classPrivateFieldGet$5(this, _XiomeNotes_instances, "m", _XiomeNotes_renderTabs).call(this)}
					<slot name="empty">
						you have no ${old ? 'old' : 'new'} notifications
					</slot>
				`
        : $ `
					${__classPrivateFieldGet$5(this, _XiomeNotes_instances, "m", _XiomeNotes_renderTabs).call(this)}
					${__classPrivateFieldGet$5(this, _XiomeNotes_instances, "m", _XiomeNotes_renderNotes).call(this)}
					${__classPrivateFieldGet$5(this, _XiomeNotes_instances, "m", _XiomeNotes_renderPagination).call(this)}
					${__classPrivateFieldGet$5(this, _XiomeNotes_instances, "m", _XiomeNotes_renderButtonbar).call(this)}
				`}
		`;
    };
    XiomeNotes = __decorate$8([
        mixinStyles(styles$8)
    ], XiomeNotes);

    var styles$7 = r$2 `

:host {
	display: inline-block;
	--xiome-notes-indicator-count-size: 1em;
	--xiome-notes-indicator-color: red;
	--xiome-notes-indicator-bleedout: 0em;
	font-size: var(--xiome-notes-indicator-size, 1em);
	width: var(--xiome-notes-indicator-icon-size, 3em);
	position: relative;
}

:host([no-icon]) .bell {
	display: none;
}

.count {
	display: flex;
	justify-content: center;
	align-items: center;
	vertical-align: top;
	position: absolute;
	height: 1em;
	width: 1em;
	background-color: var(--xiome-notes-indicator-color);
	border-radius: 50%;
	text-align: center;
	right: var(--xiome-notes-indicator-bleedout);
	top: var(--xiome-notes-indicator-bleedout);
	font-weight: bold;
	color: white;
	font-size: var(--xiome-notes-indicator-count-size);
}
`;

    var bell = y `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-bell"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>`;

    var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeNotesIndicator = class XiomeNotesIndicator extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.noIcon = false;
        }
        render() {
            const bellSpan = $ `<span class="bell">${bell}</span>`;
            const { stats } = this.share.notesModel;
            return $ `
				${stats.newCount === 0 ? $ `${bellSpan}`
            : $ `
					<span class="count">${stats.newCount}</span>
					${bellSpan}
				`}
			`;
        }
    };
    __decorate$7([
        e({ attribute: "no-icon" })
    ], XiomeNotesIndicator.prototype, "noIcon", void 0);
    XiomeNotesIndicator = __decorate$7([
        mixinStyles(styles$7)
    ], XiomeNotesIndicator);

    function integrateNotesComponents({ models: { notesModel } }) {
        return {
            XiomeNotes: (mixinSnapstateSubscriptions(notesModel.stateSubscribe)(mixinShare({
                notesModel,
            })(XiomeNotes))),
            XiomeNotesIndicator: (mixinSnapstateSubscriptions(notesModel.stateSubscribe)(mixinShare({
                notesModel,
            })(XiomeNotesIndicator))),
        };
    }

    var styles$6 = r$2 `

:host {
	display: block;
}

`;

    function renderView({ view, onDeleteClick, getPrivilegeDisplay }) {
        return $ `
		<div class="view">
			<div class="view-details">
				<div>
					<h4>hosting provider</h4>
					<p>${view.provider}</p>
				</div>
				<div>
					<h4>content type</h4>
					<p>${view.type}</p>
				</div>
				<div>
					<h4>content id</h4>
					<xio-id id="${view.id}"></xio-id>
				</div>
			</div>
			<h4>privileges with access</h4>
			<ul>
				${view.privileges.map(getPrivilegeDisplay)
        .map(privilege => privilege
        ? $ `<li>${privilege.label}</li>`
        : null)}
			</ul>
			<div class=buttonbar>
			<xio-button @press=${onDeleteClick}>
				unassign from this display
			</xio-button>
			</div>
		</div>
	`;
    }

    var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeVideoViews = class XiomeVideoViews extends mixinRequireShare()(Component) {
        async init() {
            this.share.contentModel.initializeForModerationData();
        }
        render() {
            const model = this.share.contentModel;
            return model.allowance.canModerateVideos
                ? renderOp(model.state.viewsOp, views => $ `
				<slot>
					<h3>all video views</h3>
				</slot>
				${views.length ? $ `
					<div class=views>
						${views.map(view => renderView({
                view,
                onDeleteClick: () => model.deleteView(view.label),
                getPrivilegeDisplay: id => model.getPrivilege(id),
            }))}
					</div>
				` : $ `
					<slot name=no-views>
						<p>no video views are registered</p>
					</slot>
				`}
			`)
                : $ `
				<slot name=unprivileged>
					<p>you don't have sufficient privileges to moderate video views</p>
				</slot>
			`;
        }
    };
    XiomeVideoViews = __decorate$6([
        mixinStyles(styles$6)
    ], XiomeVideoViews);

    var clockIcon = y `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>`;

    const goodApiKey = "good";

    const validateDacastApiKey = validator(validator(string(), minLength(16), maxLength(64), zeroWhitespace()));
    const validateDacastApiKeyAllowingMock = value => value === goodApiKey
        ? []
        : validateDacastApiKey(value);

    var styles$5 = r$2 `

:host {
	display: block;
	width: 24em;
	max-width: 100%;
	border: 1px solid;
	border-radius: 5px;
	--xiome-video-hosting-warning-color: red;
}

.dacastbox {
	padding: 1em;
}

xio-text-input::part(problems) {
	width: 100%;
}

.buttonbar {
	display: flex;
	flex-direction: row;
	justify-content: flex-end;
}

.buttonbar > * {
	margin: 0.4em 0.2em;
}

.failed {
	color: var(--xiome-video-hosting-warning-color);
	display: flex;
	align-items: center;
	padding: 0.5em 0;
}

.failed svg {
	margin-right: 0.5em;
}

.linked {
	display: flex;
}

.helpbox ul {
	padding-left: 1.5em;
}

.link-time-info {
	display: inline-flex;
	align-items: center;
	padding: 0.5em 0;
}


.unlink-button {
	display: flex;
	justify-content: flex-end;
}

.link-time-info svg {
	width: 6em;
	height: 3em;
}
`;

    var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldSet$2 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var __classPrivateFieldGet$4 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoHosting_showHelp, _XiomeVideoHosting_linkFailed, _XiomeVideoHosting_apiKeyDraft, _XiomeVideoHosting_handleInputChange, _XiomeVideoHosting_handleLinkClick, _XiomeVideoHosting_handleUnlinkClick, _XiomeVideoHosting_toggleHelp, _XiomeVideoHosting_renderHelp, _XiomeVideoHosting_renderWhenUnlinked, _XiomeVideoHosting_renderWhenLinked;
    let XiomeVideoHosting = class XiomeVideoHosting extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeVideoHosting_showHelp.set(this, false);
            _XiomeVideoHosting_linkFailed.set(this, false);
            _XiomeVideoHosting_apiKeyDraft.set(this, "");
            _XiomeVideoHosting_handleInputChange.set(this, ({ detail: { value } }) => {
                __classPrivateFieldSet$2(this, _XiomeVideoHosting_apiKeyDraft, value, "f");
                this.requestUpdate();
            });
            _XiomeVideoHosting_handleLinkClick.set(this, async () => {
                const apiKey = __classPrivateFieldGet$4(this, _XiomeVideoHosting_apiKeyDraft, "f");
                if (apiKey) {
                    __classPrivateFieldSet$2(this, _XiomeVideoHosting_linkFailed, false, "f");
                    __classPrivateFieldSet$2(this, _XiomeVideoHosting_apiKeyDraft, "", "f");
                    const link = await this.share.dacastModel.linkAccount({ apiKey });
                    __classPrivateFieldSet$2(this, _XiomeVideoHosting_linkFailed, !link, "f");
                }
            });
            _XiomeVideoHosting_handleUnlinkClick.set(this, async () => {
                __classPrivateFieldSet$2(this, _XiomeVideoHosting_apiKeyDraft, "", "f");
                await this.share.dacastModel.unlinkAccount();
            });
            _XiomeVideoHosting_toggleHelp.set(this, () => {
                __classPrivateFieldSet$2(this, _XiomeVideoHosting_showHelp, !__classPrivateFieldGet$4(this, _XiomeVideoHosting_showHelp, "f"), "f");
                this.requestUpdate();
            });
            _XiomeVideoHosting_renderHelp.set(this, () => {
                return $ `
			<div class=helpbox>
				<p>how to find your dacast api key:</p>
				<ul>
					<li>create a <a part=link target=_blank href="https://dacast.com/">dacast</a> account</li>
					<li>if you have a trial account, you must email support and ask them to activate your account's "api access"</li>
					<li>generate an api key in your <a part=link target=_blank href="https://app.dacast.com/settings/integrations">dacast integrations settings</a></li>
				</ul>
			</div>
		`;
            });
            _XiomeVideoHosting_renderWhenUnlinked.set(this, () => {
                return $ `
			<h2>link your dacast account</h2>
			<xio-text-input
				placeholder="api key"
				.validator=${validateDacastApiKeyAllowingMock}
				@enterpress=${__classPrivateFieldGet$4(this, _XiomeVideoHosting_handleLinkClick, "f")}
				@valuechange=${__classPrivateFieldGet$4(this, _XiomeVideoHosting_handleInputChange, "f")}>
			</xio-text-input>
			${__classPrivateFieldGet$4(this, _XiomeVideoHosting_linkFailed, "f")
                ? $ `<div class=failed>${warningSvg} <p>dacast rejected the api link</p></div>`
                : null}
			<div class=buttonbar>
				<xio-button
					class=help-button
					@press=${__classPrivateFieldGet$4(this, _XiomeVideoHosting_toggleHelp, "f")}>
						${__classPrivateFieldGet$4(this, _XiomeVideoHosting_showHelp, "f")
                ? "hide help"
                : "show help"}
				</xio-button>
				<xio-button
					class=link-button
					?disabled=${!__classPrivateFieldGet$4(this, _XiomeVideoHosting_apiKeyDraft, "f")}
					@press=${__classPrivateFieldGet$4(this, _XiomeVideoHosting_handleLinkClick, "f")}>
						link
				</xio-button>
			</div>
			${__classPrivateFieldGet$4(this, _XiomeVideoHosting_showHelp, "f")
                ? __classPrivateFieldGet$4(this, _XiomeVideoHosting_renderHelp, "f").call(this)
                : null}
		`;
            });
            _XiomeVideoHosting_renderWhenLinked.set(this, (linkedAccount) => {
                return $ `
			<h2>your dacast account is linked</h2>
			<div class=link-time-info>
				${clockIcon}
				<p>linked on ${formatDate(linkedAccount.time).full}</p>
			</div>
			<div class=unlink-button>
				<xio-button @press=${__classPrivateFieldGet$4(this, _XiomeVideoHosting_handleUnlinkClick, "f")}>unlink</xio-button>
			</div>
		`;
            });
        }
        get state() {
            return this.share.dacastModel.state;
        }
        async init() {
            await this.share.dacastModel.initialize();
        }
        render() {
            return renderOp(this.state.accessOp, access => $ `
			<div class=dacastbox>
				${access.permit.privileges.includes(videoPrivileges["moderate videos"])
            ? renderOp(this.state.linkedAccountOp, linkedAccount => linkedAccount
                ? __classPrivateFieldGet$4(this, _XiomeVideoHosting_renderWhenLinked, "f").call(this, linkedAccount)
                : __classPrivateFieldGet$4(this, _XiomeVideoHosting_renderWhenUnlinked, "f").call(this))
            : $ `<slot name=forbidden>you don't have permission to edit video hosting settings</slot>`}
			</div>
		`);
        }
    };
    _XiomeVideoHosting_showHelp = new WeakMap(), _XiomeVideoHosting_linkFailed = new WeakMap(), _XiomeVideoHosting_apiKeyDraft = new WeakMap(), _XiomeVideoHosting_handleInputChange = new WeakMap(), _XiomeVideoHosting_handleLinkClick = new WeakMap(), _XiomeVideoHosting_handleUnlinkClick = new WeakMap(), _XiomeVideoHosting_toggleHelp = new WeakMap(), _XiomeVideoHosting_renderHelp = new WeakMap(), _XiomeVideoHosting_renderWhenUnlinked = new WeakMap(), _XiomeVideoHosting_renderWhenLinked = new WeakMap();
    XiomeVideoHosting = __decorate$5([
        mixinStyles(styles$5)
    ], XiomeVideoHosting);

    var styles$4 = r$2 `

:host {
	display: block;
	--_select-bg: var(--xiome-video-display-select-background, #222);
	--xiome-video-display-selected-option-color: cyan;
}

.controls-title,
.view,
.viewcreator {
	max-width: 42rem;
}

[part="iframe"] {
	width: 100%;
	border: none;
}

.mock-embed img {
	width: 100%;
}

.buttonbar {
	text-align: right;
}

.controls-title,
.viewcreator,
.view {
	border: 1px solid;
	border-radius: 0.2em;
}

.controls-title {
	padding: 0.1em 0.5em;
}
.controls-title[data-open] {
	border-bottom-left-radius: 0;
	border-bottom-right-radius: 0;
}
.view, .viewcreator {
	border-top: 0;
	border-top-left-radius: 0;
	border-top-right-radius: 0;
}

.controls-title {
	display: flex;
	align-items: center;
}
.controls-title div span {
	display: block;
}
.controls-title span:nth-of-type(2) {
	opacity: 0.8;
	font-size: 0.8em;
	font-weight: normal;
	padding-left: 0.2em;
}

.togglebutton {
	--xio-button-border: 0;
	margin-left: auto;
	transition: transform 300ms ease;
	transform: rotate(0deg);
}
[data-open] .togglebutton {
	transform: rotate(180deg);
}

.view, .viewcreator {
	display: flex;
	flex-direction: column;
	gap: 0.2em;
	padding: 0.5em;
}

.viewcreator .selectionarea {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	width: 100%;
	gap: 0.5em;
	margin: 0.5em 0;
}

.viewcreator .selectionarea > * {
	flex: 1 1 auto;
}

select {
	color: inherit;
	background: transparent;
	border: 1px solid;
	width: 100%;
}

select[multiple] {
	min-height: 10em;
}

select option {
	padding: 0.1em 0.2em;
	color: inherit;
	background: var(--_select-bg);
}

.create-privileges {
	visibility: hidden;
}

.create-privileges[data-visible] {
	visibility: visible;
}

.create-privileges option[selected] {
	color: var(--xiome-video-display-selected-option-color);
}

::-webkit-scrollbar { width: 5px; }
::-webkit-scrollbar-thumb { background: currentColor; }

::scrollbar { width: 8px; }
::scrollbar-thumb { background: currentColor; }

/* When video is displayed css */

.view-details {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-around;
	gap: 0.8em;
	margin: 0.5em 0;
}

.view-details > * {
	text-align: center;
}

.view ul {
	display: flex;
	justify-content: left;
	text-align: center;
	list-style-type: none;
	flex-wrap: wrap;
}

.view ul li {
	border: 1px solid;
	margin: 0.2em;
	padding: 0.1em 0.4em;
	border-radius: 1em;
}

`;

    function makeHtmlElement(tag, attributes) {
        const element = document.createElement(tag);
        for (const [key, value] of Object.entries(attributes))
            element.setAttribute(key, value);
        return element;
    }

    const dacastIframeRegex = /"(https:\/\/iframe\.dacast\.com\/(\S+)\/(\S+))"/i;
    function parseDacastIframeSrc(code) {
        const parts = code.match(dacastIframeRegex);
        if (!parts)
            throw new Error(`failed to parse dacast iframe embed code: make-dacast-iframe likely needs to be updated`);
        const [, , resource, id] = parts;
        const fixedResource = resource === "playlists"
            ? "playlist"
            : resource;
        return `https://iframe.dacast.com/${fixedResource}/${id}`;
    }

    let mockCount = 0;
    function prepareEmbeds() {
        const map = new Map();
        return {
            obtain(details, mockEmbed) {
                if (details.provider !== "dacast")
                    throw new Error(`unsupported video provider "${details.provider}"`);
                let div = map.get(details.id);
                if (!div) {
                    div = makeHtmlElement("div", {
                        "data-id": details.id,
                    });
                    const embed = mockEmbed
                        ? makeHtmlElement("img", {
                            part: "iframe",
                            alt: "",
                            src: `https://source.unsplash.com/random/480x270?${mockCount++}`
                        })
                        : makeHtmlElement("iframe", {
                            src: parseDacastIframeSrc(details.embed),
                            part: "iframe",
                            allowfullscreen: "",
                            webkitallowfullscreen: "",
                            mozallowfullscreen: "",
                            oallowfullscreen: "",
                            msallowfullscreen: "",
                            frameborder: "0",
                            scrolling: "no",
                            allow: "autoplay",
                        });
                    div.appendChild(embed);
                    map.set(details.id, div);
                }
                return div;
            },
        };
    }

    function renderViewCreator({ isContentSelected, isCreateButtonDisabled, privilegesOp, catalogOp, selectedContent, queryAll, onCatalogSelect, onPrivilegesSelect, onCreateClick, isPrivilegeSelected, }) {
        const onCatalogSelectChange = (event) => {
            const target = event.target;
            onCatalogSelect(parseInt(target.value));
        };
        const onPrivilegesSelectChange = () => {
            onPrivilegesSelect(queryAll(".create-privileges select option")
                .filter(option => option.selected).map(option => option.value));
        };
        function renderContentSelector() {
            const catalog = ops.value(catalogOp);
            return $ `
			<div class=create-content>
				${catalog.length ? $ `
					<h5>Select content for this view</h5>
					<select @change=${onCatalogSelectChange}>
						${isContentSelected
            ? null
            : $ `
								<option disabled selected>
									(select video content)
								</option>
							`}
						${catalog.map(({ provider, type, title }, index) => $ `
							<option value=${index} ?selected=${index === selectedContent}>
								${`${provider} ${type} ${title}`}
							</option>
						`)}
					</select>
				` : $ `
					<p>no available video content (are your video accounts linked?)</p>
				`}
			</div>
		`;
        }
        function renderPrivilegeSelector() {
            const privileges = ops.value(privilegesOp);
            return $ `
			<div class="create-privileges" ?data-visible=${isContentSelected}>
				<h5>Select which privileges have access</h5>
				<select multiple @change=${onPrivilegesSelectChange}>
					${privileges.map(privilege => $ `
						<option
							?selected=${isPrivilegeSelected(privilege.privilegeId)}
							value="${privilege.privilegeId}">
								${privilege.label}
						</option>
					`)}
				</select>
			</div>
		`;
        }
        return renderOp(ops.combine(catalogOp, privilegesOp), () => $ `
		<div class=viewcreator>
			<h4>Assign Video Content</h4>
			<div class=selectionarea>
				${renderContentSelector()}
				${renderPrivilegeSelector()}
			</div>
			<div class=buttonbar>
				<xio-button
					class=create-button
					?disabled=${isCreateButtonDisabled}
					@press=${onCreateClick}>
						Assign To This Video
				</xio-button>
			</div>
		</div>
	`);
    }

    var triangle = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><g transform="rotate(180 8 8)"><g fill="currentColor"><path fill-rule="evenodd" d="M7.022 1.566a1.13 1.13 0 0 1 1.96 0l6.857 11.667c.457.778-.092 1.767-.98 1.767H1.144c-.889 0-1.437-.99-.98-1.767L7.022 1.566z"/></g></g></svg>`;

    function videoControls({ queryAll, contentModel: model, requestUpdate, }) {
        const { readable, writable, subscribe } = snapstate({
            open: false,
            selectedContent: undefined,
            selectedPrivileges: [],
        });
        const toggleControls = () => {
            writable.open = !writable.open;
        };
        function render(label) {
            const currentView = model.getView(label);
            return $ `
			<h3 class=controls-title ?data-open=${readable.open}>
				<div>
					<span>video display controls</span>
					<span>label = <em>"${label}"</em></span>
				</div>
				<xio-button
					class=togglebutton
					title="${readable.open ? "close" : "open"} video controls"
					@press=${toggleControls}>
						${triangle}
				</xio-button>
			</h3>
			${readable.open ? $ `
				${currentView
            ? renderView({
                view: currentView,
                onDeleteClick: () => model.deleteView(label),
                getPrivilegeDisplay: id => model.getPrivilege(id),
            })
            : renderViewCreator({
                queryAll,
                catalogOp: model.state.catalogOp,
                privilegesOp: model.state.privilegesOp,
                isContentSelected: readable.selectedContent !== undefined,
                selectedContent: readable.selectedContent,
                isCreateButtonDisabled: readable.selectedContent === undefined
                    || readable.selectedPrivileges.length === 0,
                onCatalogSelect: index => {
                    writable.selectedContent = index;
                    writable.selectedPrivileges = [];
                },
                isPrivilegeSelected: id => {
                    return readable.selectedPrivileges.some(e => e === id);
                },
                onPrivilegesSelect: privileges => {
                    writable.selectedPrivileges = privileges;
                },
                onCreateClick: () => {
                    const { selectedContent, selectedPrivileges } = readable;
                    writable.selectedContent = undefined;
                    writable.selectedPrivileges = [];
                    const content = model.catalog[selectedContent];
                    model.setView({
                        label,
                        privileges: selectedPrivileges,
                        reference: {
                            id: content.id,
                            type: content.type,
                            provider: content.provider,
                        },
                    });
                }
            })}
			` : null}
		`;
        }
        return {
            render,
            subscribe: () => subscribe(requestUpdate),
        };
    }

    var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$3 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoDisplay_instances, _XiomeVideoDisplay_model_get, _XiomeVideoDisplay_embeds, _XiomeVideoDisplay_videoControls, _XiomeVideoDisplay_renderShow;
    let XiomeVideoDisplay = class XiomeVideoDisplay extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeVideoDisplay_instances.add(this);
            this.label = "default";
            this["mock-embed"] = false;
            this["show-title"] = false;
            _XiomeVideoDisplay_embeds.set(this, prepareEmbeds());
            _XiomeVideoDisplay_videoControls.set(this, (() => {
                const controls = videoControls({
                    contentModel: __classPrivateFieldGet$3(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get),
                    requestUpdate: () => this.requestUpdate(),
                    queryAll: s => Array.from(this.shadowRoot.querySelectorAll(s)),
                });
                this.addSubscription(controls.subscribe);
                return controls;
            })());
        }
        async init() {
            await __classPrivateFieldGet$3(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).initializeForVideo(this.label);
        }
        render() {
            return renderOp(__classPrivateFieldGet$3(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).state.accessOp, () => $ `
			${__classPrivateFieldGet$3(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).allowance.canModerateVideos
            ? __classPrivateFieldGet$3(this, _XiomeVideoDisplay_videoControls, "f").render(this.label)
            : null}
			${__classPrivateFieldGet$3(this, _XiomeVideoDisplay_instances, "m", _XiomeVideoDisplay_renderShow).call(this)}
		`);
        }
    };
    _XiomeVideoDisplay_embeds = new WeakMap(), _XiomeVideoDisplay_videoControls = new WeakMap(), _XiomeVideoDisplay_instances = new WeakSet(), _XiomeVideoDisplay_model_get = function _XiomeVideoDisplay_model_get() {
        return this.share.contentModel;
    }, _XiomeVideoDisplay_renderShow = function _XiomeVideoDisplay_renderShow() {
        var _a;
        const show = __classPrivateFieldGet$3(this, _XiomeVideoDisplay_instances, "a", _XiomeVideoDisplay_model_get).getShow(this.label);
        return show
            ? show.details
                ? $ `
					${this["show-title"]
                ? $ `<h4 part=title>${show.details.title}</h4>`
                : null}
					${(_a = __classPrivateFieldGet$3(this, _XiomeVideoDisplay_embeds, "f")
                .obtain(show.details, this["mock-embed"])) !== null && _a !== void 0 ? _a : "(embed missing)"}
					<slot></slot>
				`
                : $ `<slot name=unprivileged></slot>`
            : $ `<slot name=unavailable></slot>`;
    };
    __decorate$4([
        e({ type: String })
    ], XiomeVideoDisplay.prototype, "label", void 0);
    __decorate$4([
        e({ type: Boolean, reflect: true })
    ], XiomeVideoDisplay.prototype, "mock-embed", void 0);
    __decorate$4([
        e({ type: Boolean, reflect: true })
    ], XiomeVideoDisplay.prototype, "show-title", void 0);
    XiomeVideoDisplay = __decorate$4([
        mixinStyles(styles$4)
    ], XiomeVideoDisplay);

    var styles$3 = r$2 `

:host {
	display: block;
}

`;

    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$2 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _XiomeVideoCompanion_instances, _XiomeVideoCompanion_model_get;
    let XiomeVideoCompanion = class XiomeVideoCompanion extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            _XiomeVideoCompanion_instances.add(this);
            this.label = "default";
        }
        init() {
            __classPrivateFieldGet$2(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).initializeForVideo(this.label);
        }
        render() {
            const show = __classPrivateFieldGet$2(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).getShow(this.label);
            const { accessOp, showsOp } = __classPrivateFieldGet$2(this, _XiomeVideoCompanion_instances, "a", _XiomeVideoCompanion_model_get).state;
            const combinedOp = ops.combine(accessOp, showsOp);
            return renderOp(combinedOp, () => show
                ? show.details
                    ? $ `<slot></slot>`
                    : $ `<slot name=unprivileged></slot>`
                : $ `<slot name=unavailable></slot>`);
        }
    };
    _XiomeVideoCompanion_instances = new WeakSet(), _XiomeVideoCompanion_model_get = function _XiomeVideoCompanion_model_get() {
        return this.share.contentModel;
    };
    __decorate$3([
        e({ type: String })
    ], XiomeVideoCompanion.prototype, "label", void 0);
    XiomeVideoCompanion = __decorate$3([
        mixinStyles(styles$3)
    ], XiomeVideoCompanion);

    function integrateVideoComponents({ models }) {
        const { dacastModel, contentModel } = models.videoModels;
        return {
            XiomeVideoHosting: (mixinSnapstateSubscriptions(dacastModel.subscribe)(mixinShare({
                dacastModel,
            })(XiomeVideoHosting))),
            XiomeVideoDisplay: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoDisplay))),
            XiomeVideoViews: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoViews))),
            XiomeVideoCompanion: (mixinSnapstateSubscriptions(contentModel.subscribe)(mixinShare({
                contentModel,
            })(XiomeVideoCompanion))),
        };
    }

    var styles$2 = r$2 `

:host {
	display: block;
}

`;

    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let XiomeExample = class XiomeExample extends mixinRequireShare()(Component) {
        get state() {
            return this.share.exampleModel.state;
        }
        render() {
            return renderOp(this.state.accessOp, access => $ `
			<p>Example Component</p>
			${(access === null || access === void 0 ? void 0 : access.user)
            ? $ `<p>Welcome, ${access.user.profile.nickname}</p>`
            : $ `<p>User is not logged in.</p>`}
		`);
        }
    };
    XiomeExample = __decorate$2([
        mixinStyles(styles$2)
    ], XiomeExample);

    function integrateExampleComponents({ models, modals }) {
        const { exampleModel } = models;
        return {
            XiomeExample: (mixinSnapstateSubscriptions(exampleModel.subscribe)(mixinShare({
                modals,
                exampleModel,
            })(XiomeExample))),
        };
    }

    var votingUnitCss = r$2 `

[data-vote] {
	display: block;
	border: none;
	font: inherit;
	background: transparent;
	color: inherit;
}

[data-vote] {
	cursor: pointer;
	opacity: 0.6;
	user-select: none;
}

[data-vote="report"] {
	opacity: 0.4;
}

[data-vote]:not([disabled]):hover,
[data-vote]:not([disabled]):focus {
	opacity: 1;
}

[data-vote][disabled] {
	cursor: default;
}

[data-vote="like"][data-active] {
	color: var(--like-color);
}

[data-vote="report"][data-active] {
	color: var(--report-color);
}

[data-vote] > span {
	vertical-align: middle;
}

[data-vote] > span:nth-child(2) {
	font-size: 0.9em;
}

[data-vote] svg {
	width: 1.4em;
	height: 1.4em;
	position: relative;
	top: 0.1em;
}

`;

    var postCss = r$2 `

${votingUnitCss}

.post {
	display: grid;
	grid-template-rows: auto;
	grid-template-columns: auto 1fr auto;
	grid-template-areas:
		".... tophat    ...."
		"bar1 bubble    bar2"
		".... buttonbar ....";
}

a {
	opacity: 0.5;
	color: inherit;
	text-decoration: none;
}

a:hover, a:focus {
	opacity: 0.8;
	text-decoration: underline;
}

/*
** normal questions
*/

.post .tophat { grid-area: tophat }
.post .bar1 { grid-area: bar1 }
.post .bar2 { grid-area: bar2 }
.post .bubble { grid-area: bubble }
.post .buttonbar { grid-area: buttonbar }

.post .bar {
	padding: 0.5em;
	padding-top: 0.2em;
	display: flex;
	flex-direction: column;
}

.post .bar > * + * {
	margin-top: 0.1em;
}

.post .bar.bar2 {
	padding-top: 0;
}

.post .metabar {
	font-size: 0.7em;
	padding: 0 1.5em;
	opacity: 0.6;
}

.post .tophat xio-profile-card {
	width: 100%;
}

.post .bubble {
	flex: 1 1 auto;
	/* padding-left: 1em; */
}

.post .bubble xio-text-input {
	--xio-text-input-border-radius: 0 1em 1em 1em;
	--xio-text-input-pad: 0.5em;
}

.post .bubble .textbox p {
	border-radius: 0 1em 1em 1em;
	border: 1px solid;
	padding: 0.5em;
	min-height: 4em;
}

.post [part="bubble"] {
	white-space: pre-wrap;
}

/*
** question editor
*/

.intro {
	margin-bottom: 1em;
}

.intro .heading {
	font-size: 2em;
}

.post.editor .buttonbar {
	text-align: right;
	padding: 0.5em;
}

.post.editor {
	padding-bottom: 2em;
	margin-bottom: 2em;
	border-bottom: 1px dashed;
}

`;

    var styles$1 = r$2 `

/* * {
	outline: 1px solid #f002;
} */

:host {
	display: block;
	max-width: 42em;
	--like-color: var(--xiome-questions-like-color, cyan);
	--report-color: var(--xiome-questions-report-color, #f90);
}

.questions-moderation-panel {
	padding: 1em;
	border: 1px dotted;
	margin-bottom: 1em;
}

.questions-moderation-panel .purge-button {
	--xio-button-hover-color: red;
}

slot[name="empty"] {
	display: block;
	margin-top: 1em;
}

[part="questions-list"] {
	list-style: none;

}

[part="questions-list"] > li {
	margin-top: 2em;
}

${postCss}

[part="answers-list"] {
	list-style: none;
	margin-left: 3.4em;
	margin-right: 1em;
	margin-bottom: 1em;
}

[part="answers-list"] > li {
	
	margin-top: 1em;
}

@media (max-width: 420px) {
	[part="answers-list"] {
		margin-left: 1em;
		margin-right: 0;
	}
	[part="answers-list"] > li {
		border-left: 1px solid;
	}
}

/*
** question editor
*/

.editor .intro {
	margin-bottom: 1em;
}

.editor .intro .heading {
	font-size: 2em;
}

.editor .buttonbar {
	text-align: right;
	padding: 0.5em;
}

.question-editor {
	padding-bottom: 2em;
	margin-bottom: 2em;
	border-bottom: 1px dashed;
}

/*
** answer editor
*/

.answer-editor {
	border: 1px dashed;
	margin-left: 5em;
	margin-top: 1em;
}

.answer-editor .intro {
	padding: 1em;
}

`;

    const timeFactor = 1 * day;
    function sortQuestions(questions, myUserId) {
        const myQuestions = [];
        const otherQuestions = [];
        for (const question of questions) {
            const isMine = myUserId && question.authorUserId === myUserId;
            if (isMine)
                myQuestions.push(question);
            else
                otherQuestions.push(question);
        }
        return [
            ...myQuestions.sort(compareQuestions),
            ...otherQuestions.sort(compareQuestions),
        ];
    }
    function compareQuestions(a, b) {
        const promoteA = -1;
        const promoteB = 1;
        const scoreA = score(a);
        const scoreB = score(b);
        if (scoreA > scoreB)
            return promoteA;
        if (scoreB < scoreA)
            return promoteB;
        return 0;
    }
    function score({ timePosted, likes, reports }) {
        return timePosted
            + voteValue(likes, timeFactor)
            - voteValue(reports, 2 * timeFactor);
    }
    function voteValue(votes, timeFactor) {
        const voteWeight = votes === 0
            ? 0
            : 1 + Math.log10(votes);
        return voteWeight * timeFactor;
    }

    const validatePostContent = validator(string(), minLength(10), maxLength(280), notWhitespace());

    function renderBubble({ content, editable, timePosted, handleValueChange = () => { }, }) {
        const { date, time } = formatDate(timePosted);
        return $ `
		<div class=bubble ?data-editable=${editable}>
			<div class=textbox>
				${editable
        ? $ `
						<xio-text-input
							exportparts="textinput: bubble"
							textarea
							.validator=${validatePostContent}
							@valuechange=${handleValueChange}
						></xio-text-input>
					`
        : $ `
						<p part=bubble>${content}</p>
					`}
			</div>
			<div class=metabar>
				<p>${`${date} ${time}`}</p>
			</div>
		</div>
	`;
    }

    function linkClick(handler) {
        return (event) => {
            event.preventDefault();
            handler();
        };
    }

    var PostType;
    (function (PostType) {
        PostType[PostType["Question"] = 0] = "Question";
        PostType[PostType["Answer"] = 1] = "Answer";
        PostType[PostType["Editor"] = 2] = "Editor";
    })(PostType || (PostType = {}));

    var heartSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M6.736 4C4.657 4 2.5 5.88 2.5 8.514c0 3.107 2.324 5.96 4.861 8.12a29.66 29.66 0 0 0 4.566 3.175l.073.041l.073-.04c.271-.153.661-.38 1.13-.674c.94-.588 2.19-1.441 3.436-2.502c2.537-2.16 4.861-5.013 4.861-8.12C21.5 5.88 19.343 4 17.264 4c-2.106 0-3.801 1.389-4.553 3.643a.75.75 0 0 1-1.422 0C10.537 5.389 8.841 4 6.736 4zM12 20.703l.343.667a.75.75 0 0 1-.686 0l.343-.667zM1 8.513C1 5.053 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262a31.146 31.146 0 0 1-5.233 3.576l-.025.013l-.007.003l-.002.001l-.344-.666l-.343.667l-.003-.002l-.007-.003l-.025-.013A29.308 29.308 0 0 1 10 20.408a31.147 31.147 0 0 1-3.611-2.632C3.8 15.573 1 12.332 1 8.514z" fill="currentColor"/></svg>`;

    var heartFillSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><path d="M14 20.408c-.492.308-.903.546-1.192.709c-.153.086-.308.17-.463.252h-.002a.75.75 0 0 1-.686 0a16.709 16.709 0 0 1-.465-.252a31.147 31.147 0 0 1-4.803-3.34C3.8 15.572 1 12.331 1 8.513C1 5.052 3.829 2.5 6.736 2.5C9.03 2.5 10.881 3.726 12 5.605C13.12 3.726 14.97 2.5 17.264 2.5C20.17 2.5 23 5.052 23 8.514c0 3.818-2.801 7.06-5.389 9.262A31.146 31.146 0 0 1 14 20.408z" fill="currentColor"/></svg>`;

    function renderVotingUnit({ title, dataVote, voteCount, voteCasted, icon, castVote, }) {
        const handleClick = castVote
            ? voteCasted
                ? () => castVote(false)
                : () => castVote(true)
            : () => { };
        return $ `
		<button
			tabindex=0
			data-vote="${dataVote}"
			?data-active=${voteCasted}
			?disabled=${!castVote}
			title="${title}"
			@click=${handleClick}>
				<span>${icon}</span>
				<span>${voteCount}</span>
		</button>
	`;
    }

    function renderLiking(liking) {
        return renderVotingUnit({
            dataVote: "like",
            icon: liking.liked
                ? heartFillSvg
                : heartSvg,
            title: liking.liked
                ? "unlike this post"
                : "like this post",
            voteCount: liking.likes,
            voteCasted: liking.liked,
            castVote: liking.castLikeVote
                ? status => liking.castLikeVote(status)
                : undefined,
        });
    }

    var warningFillSvg = y `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 20 20"><g fill="none"><path d="M8.686 2.852L2.127 14.777A1.5 1.5 0 0 0 3.441 17H16.56a1.5 1.5 0 0 0 1.314-2.223L11.314 2.852a1.5 1.5 0 0 0-2.628 0zM10 6.75a.75.75 0 0 1 .75.75v4a.75.75 0 0 1-1.5 0v-4a.75.75 0 0 1 .75-.75zm.75 7a.75.75 0 1 1-1.5 0a.75.75 0 0 1 1.5 0z" fill="currentColor"/></g></svg>`;

    function renderReporting(reporting) {
        return renderVotingUnit({
            dataVote: "report",
            icon: reporting.reported
                ? warningFillSvg
                : warningSvg,
            title: reporting.reported
                ? "unreport this post"
                : "report this post",
            voteCount: reporting.reports,
            voteCasted: reporting.reported,
            castVote: reporting.castReportVote
                ? status => reporting.castReportVote(status)
                : undefined,
        });
    }

    function renderPostStructure({ postOptions, bar1, bubble, bar2, buttonBar }) {
        var _a;
        return $ `
		<div class=post data-post-id="${(_a = postOptions.postId) !== null && _a !== void 0 ? _a : ""}">
			<div class=tophat>
				<xio-profile-card .user=${postOptions.author} show-details></xio-profile-card>
			</div>
			<div class="bar bar1">
				${bar1}
			</div>
			${bubble}
			<div class="bar bar2">
				${bar2}
			</div>
			${buttonBar
        ? $ `
					<div class=buttonbar>
						${buttonBar}
					</div>
				`
        : null}
		</div>
	`;
    }

    function renderPost(options) {
        const { author, content, timePosted, ...specificOptions } = options;
        switch (specificOptions.type) {
            case PostType.Question: {
                const { liking, reporting, deletePost, toggleAnswerEditor } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: $ `
					${renderLiking(liking)}
				`,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: false,
                        handleValueChange: undefined,
                    }),
                    bar2: $ `
					${renderReporting(reporting)}
					${deletePost
                    ? $ `<a href="#" @click=${linkClick(deletePost)}>delete</a>`
                    : null}
					${toggleAnswerEditor
                    ? $ `<a href="#" @click=${linkClick(toggleAnswerEditor)}>answer</a>`
                    : null}
				`,
                    buttonBar: undefined,
                });
            }
            case PostType.Answer: {
                const { liking, reporting, deletePost } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: $ `
					${renderLiking(liking)}
				`,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: false,
                        handleValueChange: undefined,
                    }),
                    bar2: $ `
					${renderReporting(reporting)}
					${deletePost
                    ? $ `<a href="#" @click=${linkClick(deletePost)}>delete</a>`
                    : null}
				`,
                    buttonBar: undefined,
                });
            }
            case PostType.Editor: {
                const { isPostable, postButtonText, changeDraftContent, submitPost } = specificOptions;
                return renderPostStructure({
                    postOptions: options,
                    bar1: null,
                    bubble: renderBubble({
                        content,
                        timePosted,
                        editable: true,
                        handleValueChange: changeDraftContent,
                    }),
                    bar2: null,
                    buttonBar: $ `
					<xio-button
						?disabled=${!isPostable}
						@click=${submitPost}
							>${postButtonText}</xio-button>
				`,
                });
            }
        }
    }

    function renderAnswer({ answer, questionId, modals, boardModel, canDeleteAnswer, }) {
        const permissions = boardModel.getPermissions();
        const canLike = permissions["like questions"];
        const canReport = permissions["report questions"];
        return renderPost({
            type: PostType.Answer,
            postId: answer.answerId,
            author: boardModel.getUser(answer.authorUserId),
            content: answer.content,
            timePosted: answer.timePosted,
            liking: {
                liked: answer.liked,
                likes: answer.likes,
                castLikeVote: canLike
                    ? like => boardModel.likeAnswer(questionId, answer.answerId, like)
                    : undefined,
            },
            reporting: {
                reported: answer.reported,
                reports: answer.reports,
                castReportVote: canReport
                    ? async (report) => {
                        const confirmed = report
                            ? await modals.confirm({
                                title: "Report answer?",
                                body: "Are you sure you want to submit a report against this answer?",
                                yes: { vibe: "negative", label: "Submit report" },
                                no: { vibe: "neutral", label: "Nevermind" },
                                focusNthElement: 2,
                            })
                            : true;
                        if (confirmed)
                            await boardModel.reportAnswer(questionId, answer.answerId, report);
                    }
                    : undefined,
            },
            deletePost: canDeleteAnswer(answer)
                ? async () => {
                    const confirmed = await modals.confirm({
                        title: "Delete answer?",
                        body: "Are you sure you want to delete this answer? This cannot be undone.",
                        yes: { vibe: "negative", label: "Delete answer" },
                        no: { vibe: "neutral", label: "Nevermind" },
                        focusNthElement: 2,
                    });
                    if (confirmed)
                        await boardModel.archiveAnswer(questionId, answer.answerId, true);
                }
                : undefined,
        });
    }

    function renderAnswerEditor({ now, boardModel, answerEditor, }) {
        const answerEditorState = answerEditor.state;
        return $ `
		<div class="editor answer-editor">
			<div class=intro>
				<p class=heading>Post your answer</p>
			</div>
			${renderPost({
        author: boardModel.getAccess().user,
        type: PostType.Editor,
        timePosted: now,
        postButtonText: "post answer",
        content: answerEditorState.draftText,
        isPostable: answerEditorState.isPostable,
        submitPost: answerEditor.submitAnswer,
        changeDraftContent: answerEditor.actions.handleValueChange,
    })}
		</div>
	`;
    }

    function renderQuestion({ now, question, modals, boardModel, answerEditor, }) {
        const { questionId } = question;
        const access = boardModel.getAccess();
        const permissions = boardModel.getPermissions();
        const author = boardModel.getUser(question.authorUserId);
        const questionAuthorities = (() => {
            const isAuthor = (access && access.user)
                ? access.user.userId === author.userId
                : false;
            const canDelete = permissions["moderate questions"] || isAuthor;
            const canAnswer = permissions["answer questions"];
            const canLike = permissions["like questions"];
            const canReport = permissions["report questions"];
            return { canDelete, canAnswer, canLike, canReport };
        })();
        const handleDelete = async () => {
            const confirmed = await modals.confirm({
                title: "Delete question?",
                body: "Are you sure you want to delete this question? This cannot be undone.",
                yes: { vibe: "negative", label: "Delete question" },
                no: { vibe: "neutral", label: "Nevermind" },
                focusNthElement: 2,
            });
            if (confirmed)
                await boardModel.archiveQuestion(questionId, true);
        };
        const handleLike = (like) => {
            boardModel.likeQuestion(questionId, like);
        };
        const handleReport = async (report) => {
            const confirmed = report
                ? await modals.confirm({
                    title: "Report question?",
                    body: "Are you sure you want to submit a report against this question?",
                    yes: { vibe: "negative", label: "Submit report" },
                    no: { vibe: "neutral", label: "Nevermind" },
                    focusNthElement: 2,
                })
                : true;
            if (confirmed)
                await boardModel.reportQuestion(questionId, report);
        };
        const answerEditorState = answerEditor.state;
        const canDeleteAnswer = (answer) => {
            var _a;
            const isAuthor = ((_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId) === answer.authorUserId;
            return permissions["moderate questions"] || isAuthor;
        };
        return $ `
		${renderPost({
        type: PostType.Question,
        author,
        content: question.content,
        deletePost: questionAuthorities.canDelete
            ? handleDelete
            : undefined,
        liking: {
            liked: question.liked,
            likes: question.likes,
            castLikeVote: questionAuthorities.canLike
                ? handleLike
                : undefined,
        },
        postId: question.questionId,
        reporting: {
            reported: question.reported,
            reports: question.reports,
            castReportVote: questionAuthorities.canReport
                ? handleReport
                : undefined,
        },
        timePosted: question.timePosted,
        toggleAnswerEditor: questionAuthorities.canAnswer
            ? answerEditor.actions.toggleEditMode
            : undefined,
    })}
		${answerEditorState.editMode
        ? renderAnswerEditor({ now, boardModel, answerEditor })
        : null}
		${question.answers.length ? $ `
			<ol part=answers-list>
				${question.answers.map(answer => $ `
					<li part=answer data-answer-id="${answer.answerId}">
						${renderAnswer({
        answer,
        modals,
        questionId,
        boardModel,
        canDeleteAnswer,
    })}
					</li>
				`)}
			</ol>
		` : null}
	`;
    }

    function makeEditorState() {
        const state = snapstate({
            editMode: false,
            draftText: "",
            isPostable: false,
        });
        return {
            ...state,
            actions: {
                toggleEditMode() {
                    state.writable.editMode = !state.writable.editMode;
                },
                handleValueChange(event) {
                    state.writable.draftText = event.detail.value;
                    state.writable.isPostable = !!state.writable.draftText;
                },
            },
        };
    }

    function makeQuestionEditor({ requestUpdate, getTextInput, getBoardModel, }) {
        const state = makeEditorState();
        state.subscribe(requestUpdate);
        const resetEditor = () => {
            const input = getTextInput();
            input.text = "";
        };
        return {
            state: state.readable,
            actions: state.actions,
            subscribe: state.subscribe,
            getTextInput,
            submitQuestion: async () => {
                const { draftText } = state.readable;
                resetEditor();
                await getBoardModel().postQuestion({
                    content: draftText,
                });
            },
        };
    }

    function makeAnswerEditorGetter({ requestUpdate, getBoardModel, getTextInput, }) {
        const getRecord = strongRecordKeeper()(questionId => {
            const state = makeEditorState();
            state.subscribe(requestUpdate);
            const resetEditor = () => {
                const input = getTextInput(questionId);
                input.text = "";
            };
            return {
                state: state.readable,
                actions: state.actions,
                subscribe: state.subscribe,
                submitAnswer: async () => {
                    const { draftText } = state.readable;
                    resetEditor();
                    state.actions.toggleEditMode();
                    await getBoardModel().postAnswer(questionId, { content: draftText });
                },
            };
        });
        return (questionId) => getRecord(questionId);
    }

    function renderModerationPanel({ modals, board, archiveBoard }) {
        const handlePressPurgeButton = async () => {
            const confirmed = await modals.confirm({
                title: `Purge questions?`,
                body: `Are you sure you want to delete all the questions on the board "${board}"? This cannot be undone.`,
                yes: { vibe: "negative", label: "Purge all" },
                no: { vibe: "neutral", label: "Nevermind" },
                focusNthElement: 2,
            });
            if (confirmed)
                await archiveBoard();
        };
        return $ `
		<div class=questions-moderation-panel>
			<h3>moderate questions board "${board}"</h3>
			<xio-button
				class=purge-button
				@press=${handlePressPurgeButton}>
					Purge all questions
			</xio-button>
		</div>
	`;
    }

    function renderQuestionEditor({ now, access, postingOp, questionEditor, }) {
        const author = access === null || access === void 0 ? void 0 : access.user;
        const editorState = questionEditor.state;
        return renderOp(postingOp, () => $ `
		<div class="editor question-editor" part=question-editor>
			<div class=intro>
				<p class=heading>Post a new question</p>
			</div>
			${renderPost({
        type: PostType.Editor,
        author,
        content: editorState.draftText,
        isPostable: editorState.isPostable,
        timePosted: now,
        postButtonText: "post question",
        submitPost: questionEditor.submitQuestion,
        changeDraftContent: questionEditor.actions.handleValueChange,
    })}
		</div>
	`);
    }

    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet$1 = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet$1 = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeQuestions_boardModel, _XiomeQuestions_questionEditor, _XiomeQuestions_getAnswerEditor, _XiomeQuestions_now;
    let XiomeQuestions = class XiomeQuestions extends mixinTicker(1000)(mixinRequireShare()(Component)) {
        constructor() {
            super(...arguments);
            _XiomeQuestions_boardModel.set(this, void 0);
            _XiomeQuestions_questionEditor.set(this, makeQuestionEditor({
                getBoardModel: () => __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f"),
                requestUpdate: () => this.requestUpdate(),
                getTextInput: () => (this.shadowRoot.querySelector(".question-editor xio-text-input")),
            }));
            _XiomeQuestions_getAnswerEditor.set(this, makeAnswerEditorGetter({
                getBoardModel: () => __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f"),
                requestUpdate: () => this.requestUpdate(),
                getTextInput: (questionId) => (this.shadowRoot.querySelector(`[part="questions-list"] li[data-question-id="${questionId}"] xio-text-input`)),
            }));
            _XiomeQuestions_now.set(this, Date.now());
            this.board = "default";
        }
        tick() {
            __classPrivateFieldSet$1(this, _XiomeQuestions_now, Date.now(), "f");
        }
        init() {
            __classPrivateFieldSet$1(this, _XiomeQuestions_boardModel, this.share.questionsModel.makeBoardModel(this.board), "f");
            __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").loadQuestions();
        }
        renderQuestionsBoard() {
            var _a;
            const now = __classPrivateFieldGet$1(this, _XiomeQuestions_now, "f");
            const { modals } = this.share;
            const questionEditor = __classPrivateFieldGet$1(this, _XiomeQuestions_questionEditor, "f");
            const { archiveBoard } = __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f");
            const access = __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").getAccess();
            const board = __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").getBoardName();
            const boardOp = __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").getBoardOp();
            const postingOp = __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").getPostingOp();
            const permissions = __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").getPermissions();
            const questions = sortQuestions(__classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").getQuestions(), (_a = access === null || access === void 0 ? void 0 : access.user) === null || _a === void 0 ? void 0 : _a.userId);
            return renderOp(boardOp, () => $ `

			${permissions["moderate questions"]
            ? renderModerationPanel({ modals, board, archiveBoard })
            : null}

			${permissions["post questions"]
            ? renderQuestionEditor({ now, access, postingOp, questionEditor })
            : null}

			${questions.length > 0
            ? $ `
					<ol part=questions-list>
						${questions.map(question => $ `
							<li data-question-id="${question.questionId}">
								${renderQuestion({
                question,
                now: __classPrivateFieldGet$1(this, _XiomeQuestions_now, "f"),
                modals: this.share.modals,
                boardModel: __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f"),
                answerEditor: __classPrivateFieldGet$1(this, _XiomeQuestions_getAnswerEditor, "f").call(this, question.questionId),
            })}
							</li>
						`)}
					</ol>
				`
            : $ `<slot name=empty><p>Be the first to post a question!</p></slot>`}
		`);
        }
        render() {
            return __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f") && __classPrivateFieldGet$1(this, _XiomeQuestions_boardModel, "f").getBoardOp()
                ? this.renderQuestionsBoard()
                : null;
        }
    };
    _XiomeQuestions_boardModel = new WeakMap(), _XiomeQuestions_questionEditor = new WeakMap(), _XiomeQuestions_getAnswerEditor = new WeakMap(), _XiomeQuestions_now = new WeakMap();
    __decorate$1([
        e({ type: String, reflect: true })
    ], XiomeQuestions.prototype, "board", void 0);
    XiomeQuestions = __decorate$1([
        mixinStyles(styles$1)
    ], XiomeQuestions);

    function integrateQuestionsComponents({ models, modals }) {
        const { questionsModel } = models;
        return {
            XiomeQuestions: mixinSnapstateSubscriptions(questionsModel.subscribe)(mixinShare({
                modals,
                questionsModel,
            })(XiomeQuestions)),
        };
    }

    var styles = r$2 `

.container {
	display: block;
	width: 100%;
	max-width: 36em;
	padding: 0.5em !important;
	border: 1px solid;
}

.results {
	margin-top: 0.5em;
}

.userlist {
	list-style: none;
}

.userlist > li {
	display: flex;
	flex-direction: column;
	flex-wrap: wrap;
	background: #0002;
	padding: 0.5em;
	margin-top: 0.5em;
}

.userinfo {
	display: flex;
	flex-direction: row;
}

.userinfo xio-profile-card {
	flex: 1 1 auto;
}

.userinfo .controls {
	margin-left: 1em;
}

.userinfo .controls .edit[data-edit-mode] {
	color: lime;
	--xio-button-hover-color: lime;
}

.editwidget > div {
	margin-top: 1em;
}

.editwidget header + * {
	margin-top: 0.25em;
}

.editwidget header small {
	font-size: inherit;
	opacity: 0.6;
}

.editwidget ul {
	list-style: none;
}

.editwidget .allprivileges li {
	display: inline-block;
	font-size: 0.75em;
	padding: 0.1em 0.3em;
	margin: 0.2em 0.1em;
	border: 1px solid;
	border-radius: 1em;
}

`;

    function makeUserStates({ getUserResultsOp, rerender, }) {
        const states = new Map();
        function cleanupObsoleteStates() {
            const userIdsPendingRemovalFromState = [];
            const userResultsOp = getUserResultsOp();
            if (ops.ready(userResultsOp)) {
                const userResults = ops.value(userResultsOp);
                for (const stateUserId of states.keys()) {
                    const userIsGone = !userResults.find(({ user }) => user.userId === stateUserId);
                    if (userIsGone)
                        userIdsPendingRemovalFromState.push(stateUserId);
                }
            }
            for (const obsoleteUserId of userIdsPendingRemovalFromState)
                states.delete(obsoleteUserId);
        }
        function obtainStateForUser(userId) {
            let state = states.get(userId);
            if (!state) {
                const newState = {
                    editMode: false,
                    toggleEditMode() {
                        newState.editMode = !newState.editMode;
                        rerender();
                    },
                };
                state = newState;
                states.set(userId, state);
            }
            return state;
        }
        return {
            cleanupObsoleteStates,
            obtainStateForUser,
        };
    }

    function sortAssignableFirst(roles) {
        const assignable = roles.filter(role => role.assignable);
        const notAssignable = roles.filter(role => !role.assignable);
        return [...assignable, ...notAssignable];
    }
    function renderRoleButton(role, onClick) {
        return $ `
		<xio-button
			?disabled=${!role.assignable}
			title=${role.roleId}
			data-role-id=${role.roleId}
			@press=${() => onClick(role)}>
				${role.label}
		</xio-button>
	`;
    }
    function renderPrivilegeUserHas(privilege) {
        return $ `
		<li
			title="${privilege.privilegeId}"
			data-privilege-id="${privilege.privilegeId}">
				${privilege.label}
		</li>
	`;
    }
    function renderEditWidget({ permissions, administrativeModel, updateLocalUserResultsCache, userResult: { user: { userId }, roleIds }, blur, search, }) {
        const rolesAssigned = sortAssignableFirst(roleIds
            .map(id => permissions.roles.find(role => role.roleId === id))
            .filter(id => !!id));
        const rolesAvailable = sortAssignableFirst(permissions.roles
            .filter(role => !roleIds.includes(role.roleId))
            .filter(id => !!id));
        const privilegesUserHas = permissions.privileges
            .filter(privilege => {
            const rolesWithThisPrivilege = permissions.rolesHavePrivileges
                .filter(r => r.active && r.privilegeId === privilege.privilegeId);
            const rolesUserHas = rolesWithThisPrivilege
                .filter(r => roleIds.includes(r.roleId));
            return rolesUserHas.length > 0;
        });
        async function ifChangingSelfThenReauthorize() {
            var _a, _b;
            if (userId === ((_b = (_a = administrativeModel.getAccess()) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.userId))
                await administrativeModel.reauthorize();
        }
        async function clickToAssign({ roleId }) {
            await administrativeModel.assignRoleToUser({
                userId,
                roleId,
                isPublic: true,
                timeframeEnd: undefined,
                timeframeStart: undefined,
            });
            updateLocalUserResultsCache.assignRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        async function clickToRevoke({ roleId }) {
            await administrativeModel.revokeRoleFromUser({
                userId,
                roleId,
            });
            updateLocalUserResultsCache.revokeRole(userId, roleId);
            blur();
            await ifChangingSelfThenReauthorize();
            await search();
        }
        return $ `
		<div class=editwidget>
			<div class=available>
				<header>roles available <small>(click to assign)</small></header>
				<div>
					${rolesAvailable.map(role => renderRoleButton(role, clickToAssign))}
				</div>
			</div>
			<div class=assigned>
				<header>roles assigned <small>(click to revoke)</small></header>
				<div>
					${rolesAssigned.map(role => renderRoleButton(role, clickToRevoke))}
				</div>
			</div>
			<div class=allprivileges>
				<header>user has these privileges</header>
				<ul>
					${privilegesUserHas.map(renderPrivilegeUserHas)}
				</ul>
			</div>
		</div>
	`;
    }

    const validateUserSearchTerm = validator(string(), minLength(1), maxLength(64));

    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };
    var _XiomeManageUsers_search, _XiomeManageUsers_lastSearch;
    let XiomeManageUsers = class XiomeManageUsers extends mixinRequireShare()(Component) {
        constructor() {
            super(...arguments);
            this.userResults = ops.ready([]);
            this.updateLocalUserResultsCache = {
                assignRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: [...result.roleIds, roleId] }
                        : result));
                },
                revokeRole: (userId, roleId) => {
                    if (!ops.ready(this.userResults))
                        throw new Error("error updating user cache");
                    const userResults = ops.value(this.userResults);
                    this.userResults = ops.ready(userResults.map(result => result.user.userId === userId
                        ? { user: result.user, roleIds: result.roleIds.filter(id => id !== roleId) }
                        : result));
                },
            };
            this.userStates = makeUserStates({
                getUserResultsOp: () => this.userResults,
                rerender: () => this.requestUpdate(),
            });
            _XiomeManageUsers_search.set(this, "");
            _XiomeManageUsers_lastSearch.set(this, "");
            this.commitSearch = async () => {
                const isRedundantSearch = __classPrivateFieldGet(this, _XiomeManageUsers_search, "f") === __classPrivateFieldGet(this, _XiomeManageUsers_lastSearch, "f");
                __classPrivateFieldSet(this, _XiomeManageUsers_lastSearch, __classPrivateFieldGet(this, _XiomeManageUsers_search, "f"), "f");
                if (!isRedundantSearch) {
                    this.userResults = ops.ready([]);
                    if (__classPrivateFieldGet(this, _XiomeManageUsers_search, "f"))
                        await ops.operation({
                            setOp: op => this.userResults = op,
                            promise: this.share.administrativeModel.searchUsers({
                                term: __classPrivateFieldGet(this, _XiomeManageUsers_search, "f"),
                            })
                        });
                }
                this.userStates.cleanupObsoleteStates();
            };
            this.commitSearchSoon = debounce(1000, this.commitSearch);
            this.searchChange = (event) => {
                var _a;
                __classPrivateFieldSet(this, _XiomeManageUsers_search, (_a = event.detail.value) !== null && _a !== void 0 ? _a : "", "f");
                this.commitSearchSoon();
            };
            this.enterPress = () => {
                this.commitSearch();
            };
        }
        init() {
            this.share.administrativeModel.initialize();
        }
        render() {
            const { permissionsOp } = this.share.administrativeModel.state;
            const allowed = this.share.administrativeModel
                .isAllowed("administrate user roles");
            const renderUser = (userResult) => {
                const { user } = userResult;
                const state = this.userStates.obtainStateForUser(user.userId);
                return $ `
				<li>
					<div class=userinfo>
						<xio-profile-card
							.user=${user}
							show-details
						></xio-profile-card>
						<div class=controls>
							<xio-button
								class=edit
								?data-edit-mode=${state.editMode}
								@press=${state.toggleEditMode}>
									${wrenchSvg}
							</xio-button>
						</div>
					</div>
					${state.editMode
                ? renderOp(permissionsOp, permissions => renderEditWidget({
                    userResult,
                    permissions,
                    administrativeModel: this.share.administrativeModel,
                    updateLocalUserResultsCache: this.updateLocalUserResultsCache,
                    blur: () => {
                        const activeElement = document.activeElement;
                        if (activeElement)
                            activeElement.blur();
                    },
                    search: () => this.commitSearch(),
                }))
                : null}
				</li>
			`;
            };
            return $ `
			<div class=container>

				${allowed ? $ `
					<xio-text-input
						placeholder="search for users"
						.validator=${validateUserSearchTerm}
						@valuechange=${this.searchChange}
						@enterpress=${this.enterPress}
					></xio-text-input>

					<div class=results>
						${renderOp(this.userResults, results => results.length > 0
            ? $ `
								<ol class=userlist>
									${results.map(renderUser)}
								</ol>
							`
            : $ `
								<div class=noresults>
									no results
								</div>
							`)}
					</div>
				` : $ `
					<p>you are not permitted to administrate user roles</p>
				`}

			</div>
		`;
        }
    };
    _XiomeManageUsers_search = new WeakMap(), _XiomeManageUsers_lastSearch = new WeakMap();
    __decorate([
        e()
    ], XiomeManageUsers.prototype, "userResults", void 0);
    XiomeManageUsers = __decorate([
        mixinStyles(styles)
    ], XiomeManageUsers);

    function integrateAdministrativeComponents({ models, modals }) {
        const { administrativeModel } = models;
        return {
            XiomeManageUsers: (mixinSnapstateSubscriptions(administrativeModel.subscribe)(mixinShare({
                modals,
                administrativeModel,
            })(XiomeManageUsers))),
        };
    }

    function getComponents(options) {
        return themeComponents(theme, {
            ...integrateXioComponents(),
            ...integrateExampleComponents(options),
            ...integrateAuthComponents(options),
            ...integrateQuestionsComponents(options),
            ...integrateAdministrativeComponents(options),
            ...integrateVideoComponents(options),
            ...integrateChatComponents(options),
            ...integrateNotesComponents(options),
            // // TODO reactivate store
            // ...xiomeStoreComponents(options),
        });
    }

    function trapFocus(element, focusNth) {
        const blueprint = `
		[focusable]:not([disabled])
		[tabindex]:not([disabled])
		a[href]:not([disabled])
		button:not([disabled])
		textarea:not([disabled])
		input[type="text"]:not([disabled])
		input[type="radio"]:not([disabled])
		input[type="checkbox"]:not([disabled])
		select:not([disabled])
	`;
        const selector = blueprint
            .split("\n")
            .map(l => l.trim())
            .filter(l => l.length)
            .join(", ");
        const focusable = Array.from(element.querySelectorAll(selector));
        if (focusable.length === 0)
            throw new Error("cannot trap focus: no focusable element");
        const firstFocusable = focusable[0];
        const lastFocusable = focusable[focusable.length - 1];
        const nthFocusable = focusable[focusNth - 1];
        setTimeout(() => nthFocusable.focus(), 0);
        element.onkeydown = event => {
            if (event.key === "Tab") {
                if (event.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        event.preventDefault();
                    }
                }
                else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        event.preventDefault();
                    }
                }
            }
        };
    }

    function preparePrompt(popup) {
        return async ({ title, input, body = null, yes = { label: "okay", vibe: "positive" }, no = { label: "nevermind", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansCancel = true, }) => new Promise(resolve => {
            var _a;
            const xioTextInput = document.createElement("xio-text-input");
            xioTextInput.textarea = (_a = input.textarea) !== null && _a !== void 0 ? _a : false;
            xioTextInput.parser = input.parser;
            xioTextInput.validator = input.validator;
            xioTextInput.textContent = input.label;
            function hasProblems() {
                void xioTextInput.value;
                return xioTextInput.problems.length !== 0;
            }
            function getCurrentValue() {
                return hasProblems()
                    ? undefined
                    : { value: xioTextInput.value };
            }
            function prepareFinishingMoves(controls) {
                return {
                    yes: () => {
                        const currentValue = getCurrentValue();
                        if (!hasProblems()) {
                            controls.close();
                            resolve(currentValue);
                        }
                    },
                    no: () => {
                        controls.close();
                        resolve(undefined);
                    },
                };
            }
            const { controls, modal } = popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansCancel
                    ? controls => {
                        controls.close();
                        resolve(undefined);
                    }
                    : () => { },
                renderContent: controls => {
                    const finish = prepareFinishingMoves(controls);
                    return $ `
					<div data-confirm>
						${typeof title == "string" ? $ `<h2>${title}</h2>` : title}
						${typeof body == "string" ? $ `<p>${body}</p>` : body}
						${xioTextInput}
						<div data-buttons>
							<xio-button
								data-button=yes
								data-vibe=${yes.vibe}
								?disabled=${hasProblems()}
								@press=${finish.yes}>
									${yes.label}
							</xio-button>
							<xio-button
								data-button=no
								data-vibe=${no.vibe}
								@press=${finish.no}>
									${no.label}
							</xio-button>
						</div>
					</div>
				`;
                },
            });
            const finish = prepareFinishingMoves(controls);
            xioTextInput.onvaluechange = () => controls.rerender();
            xioTextInput.onenterpress = () => finish.yes();
            modal.addEventListener("keyup", ({ key }) => {
                if (key === "Escape")
                    finish.no();
            });
        });
    }

    function prepareConfirm(popup) {
        return async ({ title, body = null, yes = { label: "yes", vibe: "positive" }, no = { label: "no", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansNo = true, }) => new Promise(resolve => {
            popup({
                focusNthElement,
                onBlanketClick: blanketClickMeansNo
                    ? controls => {
                        controls.close();
                        resolve(false);
                    }
                    : () => { },
                renderContent: controls => {
                    const onYes = () => {
                        controls.close();
                        resolve(true);
                    };
                    const onNo = () => {
                        controls.close();
                        resolve(false);
                    };
                    return $ `
					<div data-confirm>
						${typeof title == "string" ? $ `<h2>${title}</h2>` : title}
						${typeof body == "string" ? $ `<p>${body}</p>` : body}
						<div data-buttons>
							<xio-button
								focusable
								data-button=yes
								data-vibe="${yes.vibe}"
								@press=${onYes}>
									${yes.label}
							</xio-button>
							${no ? $ `
								<xio-button
									focusable
									data-button=no
									data-vibe="${no.vibe}"
									@press=${onNo}>
										${no.label}
								</xio-button>
							` : null}
						</div>
					</div>
				`;
                },
            });
        });
    }

    var modalSystemStyles = r$2 `

*:focus {
	outline: var(--focus-outline);
}

[data-modal-system] {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	display: block;
}

[data-modal-system] [data-blanket] {
	z-index: 101;
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	display: block;
	background: #0008;
	backdrop-filter: blur(10px);
}

[data-modal-system] [data-plate] {
	z-index: 102;
	position: absolute;
	top: 0;
	left: 0;
	right: 0;

	width: 96%;
	max-width: 32em;
	min-height: 1em;
	margin: 2em auto;

	background: linear-gradient(to bottom right, #fff, #ccc);
	color: #444;
}

[data-modal-system] [data-content]:focus {
	outline: unset;
}

[data-modal-system] [data-confirm] {
	padding: 1em;
}

[data-modal-system] [data-buttons] {
	margin-top: 1em;
	text-align: right;
}

[data-modal-system] [data-button] {
	--xio-button-hover-color: white;
	--xio-button-hover-background: #666;
}

[data-modal-system] [data-vibe=positive] {
	color: green;
	--xio-button-hover-color: white;
	--xio-button-hover-background: green;
}

[data-modal-system] [data-vibe=negative] {
	color: #a00;
	--xio-button-hover-color: white;
	--xio-button-hover-background: #a00;
}

`;

    function prepareModalSystemRendering(listModals) {
        const style = document.createElement("style");
        x(modalSystemStyles, style);
        const element = document.createElement("div");
        element.setAttribute("data-modal-system", "");
        function rerender() {
            x($ `
			${style}
			${listModals().map(modal => modal.render())}
		`, element);
        }
        return { element, rerender };
    }

    function prepareAlert(confirm) {
        return async ({ title, body = null, button = { label: "ok", vibe: "neutral" }, focusNthElement = 1, blanketClickMeansNo = true, }) => {
            await confirm({
                title,
                body,
                blanketClickMeansNo,
                yes: button,
                no: null,
            });
        };
    }

    function setupModalSystem() {
        let count = 0;
        const modals = new Map();
        const listModals = () => Array.from(modals.values());
        const { rerender, element } = prepareModalSystemRendering(listModals);
        function popup({ focusNthElement, renderContent, onBlanketClick }) {
            var _a, _b, _c;
            const id = count++;
            const controls = {
                rerender,
                close: () => {
                    modals.delete(id);
                    rerender();
                },
            };
            const top = (_c = (_b = (_a = window.pageYOffset) !== null && _a !== void 0 ? _a : document.documentElement.scrollTop) !== null && _b !== void 0 ? _b : document.body.scrollTop) !== null && _c !== void 0 ? _c : 0;
            const handleBlanketClick = () => onBlanketClick(controls);
            modals.set(id, {
                render() {
                    return $ `
					<div data-modal="${id}">
						<div data-blanket @click=${handleBlanketClick}></div>
						<div data-plate style="top: ${top}px">
							${renderContent(controls)}
						</div>
					</div>
				`;
                },
            });
            rerender();
            const modal = element.querySelector(`[data-modal="${id}"]`);
            trapFocus(modal, focusNthElement);
            return { controls, modal };
        }
        const confirm = prepareConfirm(popup);
        return {
            modalsElement: element,
            modals: {
                popup,
                confirm,
                alert: prepareAlert(confirm),
                prompt: preparePrompt(popup),
            },
        };
    }

    function parseQuery(query = location.search) {
        const parsed = {};
        query = query.startsWith("?") ? query.slice(1) : query;
        query = query.startsWith("#") ? query.slice(1) : query;
        const parts = query.split("&");
        for (const part of parts) {
            const [key, ...rest] = part.split("=");
            const value = rest.join("=");
            parsed[decodeURIComponent(key)] = decodeURIComponent(value);
        }
        return parsed;
    }

    async function loginWithLinkTokenOrUseExistingLogin({ link, accessModel, onDone, onError, }) {
        const { hash } = new URL(link);
        const { login } = parseQuery(hash);
        if (login) {
            try {
                await accessModel.login(login);
            }
            catch (error) {
                onError(error);
            }
            onDone();
        }
        else
            await accessModel.useExistingLogin();
    }

    async function assembleAndInitializeFrontend({ appId, popups, storage, authMediator, remote, chatConnect, }) {
        const { modals, modalsElement } = setupModalSystem();
        const models = await assembleModels({
            appId,
            remote,
            popups,
            storage,
            authMediator,
            chatConnect,
        });
        const components = getComponents({ models, modals });
        await loginWithLinkTokenOrUseExistingLogin({
            accessModel: models.accessModel,
            link: window.location.toString(),
            onError: error => {
                if (error instanceof AccessLoginExpiredError)
                    modals.alert({
                        title: "expired login link",
                        body: "this login link has expired, please try again",
                    });
                else
                    modals.alert({
                        title: "invalid login link",
                        body: "something is wrong with this login link, please try again",
                    });
            },
            onDone: () => {
                window.location.hash = "";
            },
        });
        return { appId, components, models, modals, modalsElement };
    }

    async function assembleXiome(config) {
        const connection = await connect(config);
        const frontend = await assembleAndInitializeFrontend(connection);
        return { ...connection, ...frontend };
    }

    function configReading(selector) {
        const element = document.querySelector(selector);
        if (!element)
            throw new Error(`${selector} is required`);
        return {
            attr(key) {
                var _a;
                return (_a = element.getAttribute(key)) !== null && _a !== void 0 ? _a : undefined;
            },
        };
    }

    function readXiomeConfig() {
        const { attr } = configReading("xiome-config");
        return {
            appId: attr("app"),
            apiServer: attr("api-server"),
            chatServer: attr("chat-server"),
            platformOrigin: attr("platform"),
        };
    }

    void async function xiome() {
        const xiome = await assembleXiome(readXiomeConfig());
        document.body.prepend(xiome.modalsElement);
        registerComponents(xiome.components);
        window.xiome = xiome;
    }();

})();
//# sourceMappingURL=xiome.bundle.js.map
